/**
 * ================================================================
 * Cloudflare Worker - Ning's Card Store (Supabase å®Œæ•´ç‰ˆ)
 * ================================================================
 * 
 * ç›®çš„: å®Œæ•´ç§»æ¤ backend.js çš„æ‰€æœ‰åŠŸèƒ½åˆ° Supabaseï¼ŒåŒ…å«å®Œæ•´å‰ç«¯
 * éƒ¨ç½²: https://supabasefrontdemo.cnkuoc.workers.dev/
 * 
 * è³‡æ–™è¡¨çµæ§‹ (Supabase):
 * - users: æœƒå“¡è³‡æ–™
 * - product_catalog: å•†å“ç›®éŒ„
 * - orders: è¨‚å–®ä¸»æª”
 * - break_credits: åœ˜æ‹†é‡‘
 * - psa_orders: PSA é‘‘å®šè¨‚å–®
 * - shipment_records: å‡ºè²¨è¨˜éŒ„
 * - payment_records: ä»˜æ¬¾è¨˜éŒ„
 * - daily_fortune: æ¯æ—¥é‹å‹¢
 * - email_notifications: éƒµä»¶é€šçŸ¥è¨˜éŒ„
 * - admin_logs: ç®¡ç†å“¡æ“ä½œè¨˜éŒ„
 * 
 * ================================================================
 */

// ============================================
// ğŸ“Œ å®Œæ•´çš„å‰ç«¯ HTMLï¼ˆå¾ worker.html ç§»æ¤ï¼‰
// ============================================

// æ³¨æ„ï¼šé€™æ˜¯å¾ worker.html è¤‡è£½çš„å®Œæ•´å‰ç«¯ä»£ç¢¼ï¼ŒåŒ…å«æ‰€æœ‰åŠŸèƒ½ï¼š
// - ç™»å…¥/è¨»å†Š
// - å•†å“ç€è¦½ï¼ˆTopps Now å–®å¡ & å¡ç›’ï¼‰
// - è³¼ç‰©è»Š
// - è¨‚å–®æŸ¥è©¢
// - åœ˜æ‹†ç´€éŒ„
// - PSA é‘‘å®š
// - æ¯æ—¥é‹å‹¢
// - æœƒå“¡è³‡æ–™
const HTML_CONTENT = \`<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Ning's Card Store</title>
  <link rel="icon" type="image/png" href="https://i.postimg.cc/jSFPPTp5/photo-output.png">
  <style>
    :root { 
      --navy: #0a2342; --navy-2: #1c3a63; --orange: #e67e22; --red: #d32f2f; 
      --bg-light: #f8f9fa; --color-stock: #28a745; 
    }
    * { box-sizing: border-box; }
    body { font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; margin:0; padding-top: 60px; min-height: 100vh; overflow-x: hidden; }
    
    /* æµ®æ°´å° - å›ºå®šåœ¨æ•´å€‹è¦–çª—ä¸Šå±¤ */
    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url('https://i.postimg.cc/jSFPPTp5/photo-output.png');
      background-repeat: no-repeat;
      background-position: center;
      background-size: 40%;
      z-index: 99999;
      pointer-events: none;
      opacity: 0.05;
    }
    
    .app-header { position: fixed; top: 0; left: 0; right: 0; height: 60px; background: linear-gradient(90deg, var(--navy), var(--navy-2)); display: flex; align-items: center; justify-content: space-between; padding: 0 15px; z-index: 2000; box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
    .header-left { display: flex; align-items: center; gap: 15px; }
    .header-title { color: white; font-weight: bold; font-size: 18px; letter-spacing: 1px; cursor:pointer; }
    .menu-btn { background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 5px; }
    .header-right { display: flex; align-items: center; gap: 6px; }
    
    .sidebar { position: fixed; top: 0; left: 0; bottom: 0; width: 280px; background: #fff; z-index: 2500; transform: translateX(-100%); transition: transform 0.3s ease-in-out; box-shadow: 2px 0 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; }
    .sidebar.open { transform: translateX(0); }
    .sidebar-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2400; display: none; backdrop-filter: blur(2px); }
    .sidebar-overlay.show { display: block; }

// ============================================
// ğŸ“Œ Supabase å®¢æˆ¶ç«¯é¡åˆ¥
// ============================================

class SupabaseClient {
  constructor(url, key) {
    this.url = url
    this.key = key
  }

  /**
   * é€šç”¨æŸ¥è©¢æ–¹æ³•
   */
  async query(table, options = {}) {
    let url = `${this.url}/rest/v1/${table}`
    const params = new URLSearchParams()
    
    // select æ¬„ä½
    if (options.select) {
      params.append('select', options.select)
    } else {
      params.append('select', '*')
    }
    
    // eq æ¢ä»¶
    if (options.eq) {
      for (const [key, value] of Object.entries(options.eq)) {
        params.append(key, `eq.${value}`)
      }
    }
    
    // order æ’åº
    if (options.order) {
      params.append('order', options.order)
    }
    
    // limit é™åˆ¶
    if (options.limit) {
      params.append('limit', options.limit)
    }
    
    if (params.toString()) {
      url += '?' + params.toString()
    }
    
    const response = await fetch(url, {
      headers: {
        'apikey': this.key,
        'Authorization': `Bearer ${this.key}`,
        'Content-Type': 'application/json'
      }
    })
    
    if (!response.ok) {
      throw new Error(`Supabase query failed: ${response.statusText}`)
    }
    
    return await response.json()
  }

  /**
   * æŸ¥è©¢æ‰€æœ‰è³‡æ–™ï¼ˆç„¡åˆ†é é™åˆ¶ï¼‰
   * ç”¨æ–¼è¨ˆç®—ç´¯ç©å¼µæ•¸ç­‰éœ€è¦å®Œæ•´è³‡æ–™çš„å ´æ™¯
   */
  async queryAll(table, options = {}) {
    let url = `${this.url}/rest/v1/${table}`
    const params = new URLSearchParams()
    
    // select æ¬„ä½
    if (options.select) {
      params.append('select', options.select)
    } else {
      params.append('select', '*')
    }
    
    // eq æ¢ä»¶
    if (options.eq) {
      for (const [key, value] of Object.entries(options.eq)) {
        params.append(key, `eq.${value}`)
      }
    }
    
    // order æ’åº
    if (options.order) {
      params.append('order', options.order)
    }
    
    if (params.toString()) {
      url += '?' + params.toString()
    }
    
    const response = await fetch(url, {
      headers: {
        'apikey': this.key,
        'Authorization': `Bearer ${this.key}`,
        'Content-Type': 'application/json',
        'Range': '0-999999'  // è¨­å®šè¶…å¤§ç¯„åœï¼Œç¢ºä¿å–å¾—æ‰€æœ‰è³‡æ–™
      }
    })
    
    if (!response.ok) {
      throw new Error(`Supabase queryAll failed: ${response.statusText}`)
    }
    
    return await response.json()
  }

  /**
   * æ’å…¥è³‡æ–™
   */
  async insert(table, data) {
    const url = `${this.url}/rest/v1/${table}`
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'apikey': this.key,
        'Authorization': `Bearer ${this.key}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify(Array.isArray(data) ? data : [data])
    })
    
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Supabase insert failed: ${error}`)
    }
    
    return await response.json()
  }

  /**
   * æ›´æ–°è³‡æ–™
   */
  async update(table, match, data) {
    let url = `${this.url}/rest/v1/${table}`
    const params = new URLSearchParams()
    
    for (const [key, value] of Object.entries(match)) {
      params.append(key, `eq.${value}`)
    }
    
    url += '?' + params.toString()
    
    const response = await fetch(url, {
      method: 'PATCH',
      headers: {
        'apikey': this.key,
        'Authorization': `Bearer ${this.key}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify(data)
    })
    
    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Supabase update failed: ${error}`)
    }
    
    return await response.json()
  }

  /**
   * åˆªé™¤è³‡æ–™
   */
  async delete(table, match) {
    let url = `${this.url}/rest/v1/${table}`
    const params = new URLSearchParams()
    
    for (const [key, value] of Object.entries(match)) {
      params.append(key, `eq.${value}`)
    }
    
    url += '?' + params.toString()
    
    const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        'apikey': this.key,
        'Authorization': `Bearer ${this.key}`
      }
    })
    
    if (!response.ok) {
      throw new Error(`Supabase delete failed: ${response.statusText}`)
    }
    
    return true
  }
}

// ============================================
// ğŸ“Œ API è·¯ç”±è™•ç†
// ============================================

async function handleAPI(request, env) {
  try {
    const body = await request.json()
    const { action } = body
    const supabase = new SupabaseClient(env.SUPABASE_URL, env.SUPABASE_ANON_KEY)
    
    console.log(`[API] æ”¶åˆ°è«‹æ±‚: ${action}`)
    
    let result
    switch (action) {
      // æœƒå“¡ç›¸é—œ
      case 'login':
        result = await handleLogin(body, supabase)
        break
      
      case 'registerUser':
        result = await handleRegisterUser(body, supabase)
        break
      
      // å•†å“ç›¸é—œ
      case 'getOrderCatalog':
      case 'getProducts':
        result = await handleGetProducts(body, supabase)
        break
      
      // è¨‚å–®ç›¸é—œ
      case 'getOrderInfo':
        result = await handleGetOrderInfo(body, supabase)
        break
      
      case 'addOrderEntriesToMain':
        result = await handleAddOrder(body, supabase)
        break
      
      case 'getPendingPaymentKeys':
        result = await handleGetPendingPaymentKeys(body, supabase)
        break
      
      case 'notifyPaymentBulk':
        result = await handleNotifyPaymentBulk(body, supabase)
        break
      
      case 'submitPaymentNotification':
        result = await handlePaymentNotification(body, supabase)
        break
      
      case 'notifyProfileUpdate':
        result = await handleNotifyProfileUpdate(body, supabase)
        break
      
      case 'lookupOrderStatus':
        result = await handleLookupOrderStatus(body, supabase)
        break
      
      // åœ˜æ‹†é‡‘ç›¸é—œ
      case 'getBreakCredit':
        result = await handleGetBreakCredit(body, supabase)
        break
      
      case 'useBreakCredit':
        result = await handleUseBreakCredit(body, supabase)
        break
      
      // PSA é‘‘å®šç›¸é—œ
      case 'submitPsaOrder':
        result = await handleSubmitPsaOrder(body, supabase)
        break
      
      case 'lookupPsaOrders':
        result = await handleLookupPsaOrders(body, supabase)
        break
      
      // æ¯æ—¥é‹å‹¢
      case 'checkDailyFortune':
        result = await handleCheckDailyFortune(body, supabase)
        break
      
      case 'saveDailyFortune':
        result = await handleSaveDailyFortune(body, supabase)
        break
      
      // å‡ºè²¨ç›¸é—œ
      case 'createShipmentRecord':
        result = await handleCreateShipmentRecord(body, supabase)
        break
      
      case 'getShipmentRecords':
        result = await handleGetShipmentRecords(body, supabase)
        break
      
      // ç¶ ç•Œé‡‘æµ
      case 'createEcpayPayment':
        result = await handleCreateEcpayPayment(body, supabase)
        break
      
      case 'checkPaymentStatus':
        result = await handleCheckPaymentStatus(body, supabase)
        break
      
      case 'updateOrderStatusToPending':
        result = await handleUpdateOrderStatusToPending(body, supabase)
        break
      
      case 'updateBreakStatusToPending':
        result = await handleUpdateBreakStatusToPending(body, supabase)
        break
      
      // è³‡æ–™é©—è­‰
      case 'verifyData':
        result = await handleVerifyData(body, supabase)
        break
      
      default:
        result = { success: false, message: `æœªçŸ¥çš„ action: ${action}` }
    }
    
    return new Response(JSON.stringify(result), {
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      }
    })
    
  } catch (error) {
    console.error('[API Error]', error)
    return new Response(JSON.stringify({
      success: false,
      message: error.message || 'ä¼ºæœå™¨éŒ¯èª¤'
    }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      }
    })
  }
}

// ============================================
// ğŸ“Œ æœƒå“¡åŠŸèƒ½
// ============================================

/**
 * ç™»å…¥
 */
async function handleLogin(body, supabase) {
  const { phone, birthday } = body
  console.log(`[LOGIN] å˜—è©¦ç™»å…¥: phone=${phone}`)
  
  if (!phone || !birthday) {
    return { success: false, message: 'è«‹æä¾›æ‰‹æ©Ÿè™Ÿç¢¼å’Œç”Ÿæ—¥' }
  }
  
  // æŸ¥è©¢ç”¨æˆ¶
  const users = await supabase.query('users', { eq: { phone } })
  
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°æ­¤æ‰‹æ©Ÿè™Ÿç¢¼çš„æœƒå“¡è³‡æ–™' }
  }
  
  const user = users[0]
  
  // é©—è­‰ç”Ÿæ—¥ï¼ˆæ”¯æ´å¤šç¨®æ ¼å¼ï¼šMMDD, MM/DD, M/D ç­‰ï¼‰
  const userBday = String(user.birthday || '').replace(/\D/g, '').slice(-4)
  const inputBday = String(birthday).replace(/\D/g, '')
  
  if (userBday !== inputBday) {
    console.log(`[LOGIN] ç”Ÿæ—¥é©—è­‰å¤±æ•—: DB=${userBday}, Input=${inputBday}`)
    return { success: false, message: 'ç”Ÿæ—¥é©—è­‰å¤±æ•—' }
  }
  
  console.log(`[LOGIN] ç™»å…¥æˆåŠŸ: ${user.nickname}`)
  
  return {
    success: true,
    user: {
      phone: user.phone,
      nickname: user.nickname,
      email: user.email || '',
      customerName: user.real_name || user.nickname,
      address: user.address || '',
      birthday: user.birthday,
      shipStore: user.ship_store || '',
      storeNumber: user.store_number || ''
    }
  }
}

/**
 * è¨»å†Šæ–°ç”¨æˆ¶
 */
async function handleRegisterUser(body, supabase) {
  const { phone, nickname, birthday, email, address, realName } = body
  
  if (!phone || !nickname || !birthday) {
    return { success: false, message: 'è«‹å¡«å¯«å¿…å¡«æ¬„ä½' }
  }
  
  // æª¢æŸ¥æ˜¯å¦å·²è¨»å†Š
  const existing = await supabase.query('users', { eq: { phone } })
  if (existing && existing.length > 0) {
    return { success: false, message: 'æ­¤é›»è©±è™Ÿç¢¼å·²è¨»å†Š' }
  }
  
  // æ–°å¢ç”¨æˆ¶
  const newUser = {
    phone,
    nickname,
    birthday,
    email: email || null,
    address: address || null,
    real_name: realName || null,
    created_at: new Date().toISOString()
  }
  
  await supabase.insert('users', newUser)
  
  console.log(`[REGISTER] æ–°ç”¨æˆ¶è¨»å†ŠæˆåŠŸ: ${nickname}`)
  
  return { success: true, message: 'è¨»å†ŠæˆåŠŸï¼' }
}

// ============================================
// ğŸ“Œ å•†å“åŠŸèƒ½
// ============================================

/**
 * å–å¾—å•†å“ç›®éŒ„ï¼ˆå«ç´¯ç©å¼µæ•¸è¨ˆç®—ï¼‰
 * 
 * é‡è¦é‚è¼¯:
 * 1. å¾ product_catalog å–å¾—æ‰€æœ‰å•†å“
 * 2. å¾ orders è¨ˆç®—æ¯å€‹å•†å“çš„ç´¯ç©å¼µæ•¸
 * 3. Google Sheet ä¸­çš„ç´¯ç©å¼µæ•¸æ˜¯ç”¨å…¬å¼è¨ˆç®—çš„ï¼Œé€™è£¡è¦ç”¨ç¨‹å¼å¯¦ä½œ
 */
async function handleGetProducts(body, supabase) {
  console.log('[GET_PRODUCTS] é–‹å§‹æŸ¥è©¢å•†å“ç›®éŒ„')
  
  try {
    // 1. å–å¾—æ‰€æœ‰å•†å“
    const products = await supabase.query('product_catalog', {
      order: 'created_at.desc'
    })
    
    if (!products || products.length === 0) {
      return { success: true, items: [], message: 'ç›®å‰æ²’æœ‰å•†å“' }
    }
    
    console.log(`[GET_PRODUCTS] æŸ¥è©¢åˆ° ${products.length} å€‹å•†å“`)
    
    // 2. æŸ¥è©¢æ‰€æœ‰è¨‚å–®ä¾†è¨ˆç®—ç´¯ç©å¼µæ•¸
    // ğŸ”‘ é—œéµ: ä½¿ç”¨ queryAll ç¢ºä¿å–å¾—æ‰€æœ‰è¨‚å–®è³‡æ–™
    const allOrders = await supabase.queryAll('orders', {
      select: 'item,card_no,quantity'
    })
    
    console.log(`[GET_PRODUCTS] æŸ¥è©¢åˆ° ${allOrders.length} ç­†è¨‚å–®`)
    
    // 3. è¨ˆç®—æ¯å€‹å•†å“çš„ç´¯ç©å¼µæ•¸
    const accumulatedMap = new Map()
    
    if (Array.isArray(allOrders)) {
      allOrders.forEach(order => {
        const itemName = String(order.item || '').trim()
        const cardNo = String(order.card_no || '').trim()
        const key = `${itemName}||${cardNo}`
        const qty = parseInt(order.quantity) || 0
        
        if (qty > 0) {
          accumulatedMap.set(key, (accumulatedMap.get(key) || 0) + qty)
        }
      })
    }
    
    console.log(`[GET_PRODUCTS] ç´¯ç©å¼µæ•¸è¨ˆç®—å®Œæˆï¼Œå…± ${accumulatedMap.size} å€‹å•†å“æœ‰è¨‚å–®`)
    
    // 4. çµ„è£å•†å“è³‡æ–™
    const items = products.map(p => {
      const itemName = String(p.item_name || '').trim()
      const cardNo = String(p.card_no || '').trim()
      const key = `${itemName}||${cardNo}`
      const accumulated = accumulatedMap.get(key) || 0
      
      // åˆ¤æ–·å•†å“ç‹€æ…‹
      const isOpen = p.is_available !== 'N'  // åªæœ‰æ˜ç¢ºè¨­ç‚º 'N' æ‰é—œé–‰
      const isBox = p.is_box_preorder === 'true'
      
      return {
        item: p.item_name,
        cardNo: p.card_no,
        price: parseFloat(p.price) || 0,
        discountPrice: parseFloat(p.threshold_price) || parseFloat(p.price) || 0,
        fullPrice: parseFloat(p.threshold_price) || parseFloat(p.price) || 0,
        thresholdPrice: parseFloat(p.threshold_price) || parseFloat(p.price) || 0,
        threshold: parseInt(p.discount_threshold) || 0,
        minGroup: parseInt(p.min_group) || 0,
        accumulatedCount: accumulated,
        status: isOpen ? 'open' : 'closed',
        isOpen: isOpen,
        isBox: isBox ? 'Y' : 'N',
        isDirect: (p.is_direct_order === 'true' || p.is_direct_order === true) ? 'Y' : 'N',
        stock: parseInt(p.remaining_stock) || 0,
        stockStatus: p.stock_status || '',
        arrivalStatus: p.stock_status || '',
        category: p.category || 'å…¶ä»–',
        closeTime: p.close_time || '',
        images: [
          p.image_url_1 || '',
          p.image_url_2 || '',
          p.image_url_3 || ''
        ].filter(img => img),
        img1: p.image_url_1 || '',
        img2: p.image_url_2 || '',
        canDrawSp: p.can_draw_sp === 'true',
        canDrawSignature: p.can_draw_signature === 'true',
        canDrawRelic: p.can_draw_relic === 'true',
        canDrawAutoRelic: p.can_draw_auto_relic === 'true',
        description: p.description || ''
      }
    })
    
    console.log(`[GET_PRODUCTS] è¿”å› ${items.length} å€‹å•†å“`)
    
    return {
      success: true,
      items: items
    }
    
  } catch (error) {
    console.error('[GET_PRODUCTS] éŒ¯èª¤:', error)
    return {
      success: false,
      message: 'æŸ¥è©¢å•†å“å¤±æ•—: ' + error.message
    }
  }
}

// ============================================
// ğŸ“Œ è¨‚å–®åŠŸèƒ½
// ============================================

/**
 * å–å¾—ç”¨æˆ¶è¨‚å–®è³‡è¨Š
 * 
 * é‡è¦é‚è¼¯:
 * 1. å¾ users å–å¾—ç”¨æˆ¶è³‡æ–™
 * 2. å¾ orders å–å¾—è©²ç”¨æˆ¶æ‰€æœ‰è¨‚å–®
 * 3. å¾ break_credits å–å¾—åœ˜æ‹†é‡‘è¨˜éŒ„
 * 4. è¨ˆç®—æ¯ç­†è¨‚å–®çš„ç´¯ç©å¼µæ•¸ï¼ˆè©²ç”¨æˆ¶è©²å•†å“çš„ç¸½æ•¸ï¼‰
 */
async function handleGetOrderInfo(body, supabase) {
  const { phone, birthday } = body
  console.log(`[GET_ORDER_INFO] æŸ¥è©¢è¨‚å–®: phone=${phone}`)
  
  if (!phone) {
    return { success: false, message: 'è«‹æä¾›æ‰‹æ©Ÿè™Ÿç¢¼' }
  }
  
  try {
    // 1. é©—è­‰ç”¨æˆ¶
    const users = await supabase.query('users', { eq: { phone } })
    
    if (!users || users.length === 0) {
      return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶è³‡æ–™' }
    }
    
    const user = users[0]
    
    // é©—è­‰ç”Ÿæ—¥ï¼ˆå¦‚æœæœ‰æä¾›ï¼‰
    if (birthday) {
      const userBday = String(user.birthday || '').replace(/\D/g, '').slice(-4)
      const inputBday = String(birthday).replace(/\D/g, '')
      
      if (userBday !== inputBday) {
        return { success: false, message: 'ç”Ÿæ—¥é©—è­‰å¤±æ•—' }
      }
    }
    
    // 2. æŸ¥è©¢è©²ç”¨æˆ¶çš„æ‰€æœ‰è¨‚å–®
    const orders = await supabase.queryAll('orders', {
      eq: { phone },
      order: 'created_at.desc'
    })
    
    console.log(`[GET_ORDER_INFO] æŸ¥è©¢åˆ° ${orders.length} ç­†è¨‚å–®`)
    
    // 3. è¨ˆç®—æ¯å€‹å•†å“çš„ç´¯ç©å¼µæ•¸ï¼ˆç”¨æ–¼é¡¯ç¤ºè©²ç”¨æˆ¶çš„ç´¯ç©é€²åº¦ï¼‰
    const userAccumulated = new Map()
    
    if (Array.isArray(orders)) {
      orders.forEach(order => {
        const key = `${order.item}||${order.card_no}`
        const qty = parseInt(order.quantity) || 0
        userAccumulated.set(key, (userAccumulated.get(key) || 0) + qty)
      })
    }
    
    // 4. æŸ¥è©¢åœ˜æ‹†é‡‘è¨˜éŒ„
    const breaks = await supabase.query('break_credits', {
      eq: { nickname: user.nickname },
      order: 'timestamp.desc'
    })
    
    console.log(`[GET_ORDER_INFO] æŸ¥è©¢åˆ° ${breaks.length} ç­†åœ˜æ‹†è¨˜éŒ„`)
    
    // 5. æ ¼å¼åŒ–è¨‚å–®è³‡æ–™
    const formattedOrders = orders.map(o => {
      const key = `${o.item}||${o.card_no}`
      const accumulated = userAccumulated.get(key) || 0
      
      return {
        item: o.item,
        cardNo: o.card_no,
        quantity: parseInt(o.quantity) || 0,
        price: parseFloat(o.price) || 0,
        total: parseFloat(o.total_fee) || 0,
        totalFee: parseFloat(o.total_fee) || 0,
        deposit: parseFloat(o.deposit) || 0,
        balance: parseFloat(o.balance) || 0,
        balanceAmount: parseFloat(o.balance) || 0,
        status: o.status || 'æº–å‚™ä¸­',
        date: o.created_at || o.timestamp || '',
        timestamp: o.timestamp || o.created_at || '',
        imageUrl: o.image_url || '',
        image: o.image_url || '',
        arrivalStatus: o.arrival_status || 'æº–å‚™ä¸­',
        paymentNotified: o.payment_notified === true,
        accumulatedCount: accumulated
      }
    })
    
    // 6. æ ¼å¼åŒ–åœ˜æ‹†é‡‘è¨˜éŒ„
    const formattedBreaks = breaks.map(b => ({
      breakId: b.break_id,
      name: b.break_name || '',
      totalFee: parseFloat(b.total_fee) || 0,
      balance: parseFloat(b.balance) || 0,
      status: b.status || '',
      timestamp: b.timestamp || b.created_at || ''
    }))
    
    console.log(`[GET_ORDER_INFO] è¿”å› ${formattedOrders.length} ç­†è¨‚å–®, ${formattedBreaks.length} ç­†åœ˜æ‹†`)
    
    return {
      success: true,
      nickname: user.nickname,
      phone: user.phone,
      email: user.email || '',
      address: user.address || '',
      customerName: user.real_name || user.nickname,
      orders: formattedOrders,
      groupBreaks: formattedBreaks
    }
    
  } catch (error) {
    console.error('[GET_ORDER_INFO] éŒ¯èª¤:', error)
    return {
      success: false,
      message: 'æŸ¥è©¢è¨‚å–®å¤±æ•—: ' + error.message
    }
  }
}

/**
 * æ–°å¢è¨‚å–®
 * 
 * é‡è¦é‚è¼¯ï¼ˆå¾ backend.js addOrderEntriesToMain ç§»æ¤ï¼‰:
 * 1. é©—è­‰ç”¨æˆ¶å’Œå•†å“
 * 2. è¨ˆç®—ç•¶å‰ç´¯ç©å¼µæ•¸
 * 3. æª¢æŸ¥æ˜¯å¦é”åˆ°é–€æª»åƒ¹
 * 4. å¦‚æœé”åˆ°é–€æª»ï¼Œå›æº¯æ›´æ–°è©²ç”¨æˆ¶è©²å•†å“çš„æ‰€æœ‰èˆŠè¨‚å–®åƒ¹æ ¼
 * 5. æ–°å¢è¨‚å–®åˆ°è³‡æ–™åº«
 */
async function handleAddOrder(body, supabase) {
  const { nickname, phone, orderEntries } = body
  console.log(`[ADD_ORDER] æ”¶åˆ°ä¸‹å–®è«‹æ±‚: ${nickname}, ${orderEntries.length} å€‹å•†å“`)
  
  if (!orderEntries || orderEntries.length === 0) {
    return { success: false, message: 'è¨‚å–®è³‡æ–™ç‚ºç©º' }
  }
  
  try {
    // 1. é©—è­‰ç”¨æˆ¶
    const users = await supabase.query('users', { eq: { phone } })
    if (!users || users.length === 0) {
      return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶è³‡æ–™' }
    }
    
    const user = users[0]
    const userId = user.id
    
    // 2. å–å¾—å•†å“è³‡è¨Š
    const products = await supabase.query('product_catalog', {})
    const productMap = new Map()
    
    if (Array.isArray(products)) {
      products.forEach(p => {
        const key = `${String(p.item_name || '').trim()}||${String(p.card_no || '').trim()}`
        productMap.set(key, {
          imageUrl: p.image_url_1 || '',
          arrivalStatus: p.stock_status || '',
          threshold: parseInt(p.discount_threshold) || 0,
          fullPrice: parseFloat(p.threshold_price) || parseFloat(p.price) || 0,
          normalPrice: parseFloat(p.price) || 0,
          isOpen: p.is_available !== 'N',
          stock: parseInt(p.remaining_stock) || 0
        })
      })
    }
    
    // 3. è¨ˆç®—ç•¶å‰å…¨ç«™ç´¯ç©å¼µæ•¸
    const allOrders = await supabase.queryAll('orders', {
      select: 'item,card_no,quantity'
    })
    
    const globalAccumulated = new Map()
    if (Array.isArray(allOrders)) {
      allOrders.forEach(order => {
        const key = `${order.item}||${order.card_no}`
        const qty = parseInt(order.quantity) || 0
        if (qty > 0) {
          globalAccumulated.set(key, (globalAccumulated.get(key) || 0) + qty)
        }
      })
    }
    
    console.log(`[ADD_ORDER] ç•¶å‰å…¨ç«™è¨‚å–®æ•¸: ${allOrders.length}`)
    
    // 4. è™•ç†æ¯å€‹ä¸‹å–®å•†å“
    const newOrders = []
    const priceUpdateTasks = []  // éœ€è¦å›æº¯æ›´æ–°åƒ¹æ ¼çš„ä»»å‹™
    
    for (const entry of orderEntries) {
      const { item, cardNo, quantity, price } = entry
      const key = `${item}||${cardNo}`
      const productInfo = productMap.get(key)
      
      if (!productInfo) {
        console.log(`[ADD_ORDER] è­¦å‘Š: æ‰¾ä¸åˆ°å•†å“è³‡è¨Š ${key}`)
        continue
      }
      
      // æª¢æŸ¥å•†å“æ˜¯å¦é–‹æ”¾ä¸‹å–®
      if (!productInfo.isOpen) {
        console.log(`[ADD_ORDER] å•†å“å·²é—œé–‰: ${key}`)
        continue
      }
      
      const qty = parseInt(quantity) || 0
      if (qty <= 0) continue
      
      // è¨ˆç®—ç´¯ç©å¼µæ•¸ï¼ˆåŠ ä¸Šæœ¬æ¬¡ä¸‹å–®ï¼‰
      const currentAccumulated = (globalAccumulated.get(key) || 0) + qty
      const threshold = productInfo.threshold
      
      console.log(`[ADD_ORDER] ${key}: ç´¯ç©=${currentAccumulated}, é–€æª»=${threshold}`)
      
      // ğŸ”‘ åˆ¤æ–·æ˜¯å¦é”åˆ°é–€æª»åƒ¹
      let finalPrice = parseFloat(price) || productInfo.normalPrice
      let shouldUpdateOldOrders = false
      
      if (threshold > 0 && currentAccumulated >= threshold) {
        // é”åˆ°é–€æª»ï¼Œä½¿ç”¨é–€æª»åƒ¹
        finalPrice = productInfo.fullPrice
        
        // æª¢æŸ¥æ˜¯å¦å‰›å¥½é”åˆ°é–€æª»ï¼ˆä¹‹å‰ç´¯ç© < é–€æª»ï¼Œç¾åœ¨ >= é–€æª»ï¼‰
        const previousAccumulated = globalAccumulated.get(key) || 0
        if (previousAccumulated < threshold) {
          shouldUpdateOldOrders = true
          console.log(`[ADD_ORDER] å‰›é”åˆ°é–€æª»ï¼éœ€è¦å›æº¯æ›´æ–°èˆŠè¨‚å–®`)
        }
      }
      
      // è¨ˆç®—é‡‘é¡ï¼ˆç°¡åŒ–ç‰ˆï¼šå…¨é¡ç‚ºå°¾æ¬¾ï¼Œç„¡è¨‚é‡‘ï¼‰
      const totalFee = finalPrice * qty
      const deposit = 0
      const balance = totalFee
      
      // å»ºç«‹è¨‚å–®è¨˜éŒ„
      const orderRecord = {
        user_id: userId,
        phone: phone,
        nickname: nickname,
        item: item,
        card_no: cardNo,
        quantity: qty,
        price: finalPrice,
        total_fee: totalFee,
        deposit: deposit,
        balance: balance,
        status: 'æº–å‚™ä¸­',
        arrival_status: productInfo.arrivalStatus,
        image_url: productInfo.imageUrl,
        payment_notified: false,
        created_at: new Date().toISOString(),
        timestamp: new Date().toISOString()
      }
      
      newOrders.push(orderRecord)
      
      // ğŸ”‘ å¦‚æœå‰›é”åˆ°é–€æª»ï¼Œéœ€è¦å›æº¯æ›´æ–°è©²ç”¨æˆ¶è©²å•†å“çš„æ‰€æœ‰èˆŠè¨‚å–®
      if (shouldUpdateOldOrders) {
        priceUpdateTasks.push({
          phone: phone,
          item: item,
          cardNo: cardNo,
          newPrice: productInfo.fullPrice
        })
      }
    }
    
    if (newOrders.length === 0) {
      return { success: false, message: 'æ²’æœ‰æœ‰æ•ˆçš„è¨‚å–®é …ç›®' }
    }
    
    // 5. æ’å…¥æ–°è¨‚å–®
    await supabase.insert('orders', newOrders)
    console.log(`[ADD_ORDER] æˆåŠŸæ–°å¢ ${newOrders.length} ç­†è¨‚å–®`)
    
    // 6. åŸ·è¡Œåƒ¹æ ¼å›æº¯æ›´æ–°
    for (const task of priceUpdateTasks) {
      try {
        // æŸ¥è©¢è©²ç”¨æˆ¶è©²å•†å“çš„æ‰€æœ‰èˆŠè¨‚å–®
        const oldOrders = await supabase.query('orders', {
          eq: {
            phone: task.phone,
            item: task.item,
            card_no: task.cardNo
          }
        })
        
        console.log(`[ADD_ORDER] æ‰¾åˆ° ${oldOrders.length} ç­†èˆŠè¨‚å–®éœ€è¦æ›´æ–°åƒ¹æ ¼`)
        
        // æ›´æ–°æ¯ç­†èˆŠè¨‚å–®çš„åƒ¹æ ¼
        for (const oldOrder of oldOrders) {
          const oldPrice = parseFloat(oldOrder.price) || 0
          if (oldPrice !== task.newPrice) {
            const newTotalFee = task.newPrice * oldOrder.quantity
            const newBalance = newTotalFee - (parseFloat(oldOrder.deposit) || 0)
            
            await supabase.update('orders',
              { id: oldOrder.id },
              {
                price: task.newPrice,
                total_fee: newTotalFee,
                balance: newBalance
              }
            )
            
            console.log(`[ADD_ORDER] æ›´æ–°è¨‚å–® #${oldOrder.id}: ${oldPrice} â†’ ${task.newPrice}`)
          }
        }
      } catch (error) {
        console.error(`[ADD_ORDER] æ›´æ–°åƒ¹æ ¼å¤±æ•—:`, error)
      }
    }
    
    return {
      success: true,
      message: `æˆåŠŸä¸‹å–® ${newOrders.length} å€‹å•†å“`,
      orderCount: newOrders.length
    }
    
  } catch (error) {
    console.error('[ADD_ORDER] éŒ¯èª¤:', error)
    return {
      success: false,
      message: 'ä¸‹å–®å¤±æ•—: ' + error.message
    }
  }
}

// ============================================
// ğŸ“Œ ä»˜æ¬¾é€šçŸ¥åŠŸèƒ½
// ============================================

/**
 * å–å¾—å¾…ä»˜æ¬¾è¨‚å–® Key
 * å¾ payment_records è³‡æ–™è¡¨æŸ¥è©¢è©²ç”¨æˆ¶å¾…è™•ç†çš„ä»˜æ¬¾è¨˜éŒ„
 */
async function handleGetPendingPaymentKeys(body, supabase) {
  const { nickname, phone } = body
  console.log(`[GET_PENDING_KEYS] æŸ¥è©¢å¾…ä»˜æ¬¾: ${nickname}`)
  
  try {
    const records = await supabase.query('payment_records', {
      eq: { nickname, status: 'pending' }
    })
    
    const keys = records.map(r => r.payment_key).filter(k => k)
    
    console.log(`[GET_PENDING_KEYS] æ‰¾åˆ° ${keys.length} å€‹å¾…ä»˜æ¬¾ key`)
    
    return {
      success: true,
      keys: keys
    }
  } catch (error) {
    console.error('[GET_PENDING_KEYS] éŒ¯èª¤:', error)
    return { success: false, message: error.message, keys: [] }
  }
}

/**
 * æ‰¹æ¬¡ä»˜æ¬¾é€šçŸ¥
 * å°‡å¤šç­†è¨‚å–®çš„ä»˜æ¬¾è³‡è¨Šå¯«å…¥ payment_records
 */
async function handleNotifyPaymentBulk(body, supabase) {
  const { nickname, phone, orders, amount, remark } = body
  console.log(`[NOTIFY_PAYMENT_BULK] ${nickname} é€šçŸ¥ä»˜æ¬¾ ${orders.length} ç­†`)
  
  try {
    const now = new Date().toISOString()
    const records = []
    const disabledKeys = []
    
    for (const order of orders) {
      const isBox = String(order.isBox || '').toUpperCase()
      let orderType = 'single'  // å–®å¡
      if (isBox === 'Y') orderType = 'box'  // å¡ç›’
      if (isBox === 'GB') orderType = 'break'  // åœ˜æ‹†
      
      // ç”Ÿæˆå”¯ä¸€ key
      const key = `${nickname}||${order.item}||${order.cardNo}||${order.quantity}||${order.total}||${isBox}`
      disabledKeys.push(key)
      
      records.push({
        timestamp: now,
        nickname: nickname,
        phone: phone,
        payment_key: key,
        item: order.item,
        card_no: order.cardNo,
        quantity: order.quantity,
        total: order.total,
        amount: amount || 0,
        remark: remark || '',
        status: 'pending',
        order_type: orderType,
        created_at: now
      })
    }
    
    if (records.length > 0) {
      await supabase.insert('payment_records', records)
    }
    
    console.log(`[NOTIFY_PAYMENT_BULK] æˆåŠŸå»ºç«‹ ${records.length} ç­†ä»˜æ¬¾é€šçŸ¥`)
    
    // TODO: ç™¼é€ email é€šçŸ¥ç®¡ç†å“¡
    
    return {
      success: true,
      disabledKeys: disabledKeys
    }
  } catch (error) {
    console.error('[NOTIFY_PAYMENT_BULK] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

/**
 * æäº¤ä»˜æ¬¾é€šçŸ¥
 * å–®ç­†ä»˜æ¬¾é€šçŸ¥ï¼ˆå¯èƒ½åŒ…å«å¤šå€‹é …ç›®ï¼‰
 */
async function handlePaymentNotification(body, supabase) {
  const { nickname, phone, item, cardNo, quantity, total, amount, remark, type, breakId, key, status } = body
  console.log(`[PAYMENT_NOTIFICATION] ${nickname} æäº¤ä»˜æ¬¾é€šçŸ¥`)
  
  try {
    const now = new Date().toISOString()
    const paymentType = type || 'order'
    
    // æ‹†åˆ†å¤šç­†é …ç›®ï¼ˆç”¨ || åˆ†éš”ï¼‰
    const items = String(item || '').split('||').map(s => s.trim()).filter(s => s)
    const records = []
    
    if (paymentType === 'break') {
      // åœ˜æ‹†ä»˜æ¬¾é€šçŸ¥
      const breakIds = String(breakId || '').split('||').map(s => s.trim()).filter(s => s)
      
      for (let i = 0; i < items.length; i++) {
        records.push({
          timestamp: now,
          nickname: nickname,
          phone: phone,
          payment_key: key || '',
          item: items[i],
          card_no: breakIds[i] || '',  // åœ˜æ‹†ç·¨è™Ÿå­˜åœ¨ card_no
          quantity: quantity || 0,
          total: total || 0,
          amount: amount || 0,
          remark: remark || '',
          status: 'break',
          order_type: 'break',
          created_at: now
        })
      }
    } else {
      // è¨‚å–®ä»˜æ¬¾é€šçŸ¥
      const cardNos = String(cardNo || '').split('||').map(s => s.trim()).filter(s => s)
      
      for (let i = 0; i < items.length; i++) {
        const fullItem = items[i]
        const itemParts = fullItem.split(' #')
        const itemName = itemParts[0].trim()
        const cardNoFromItem = itemParts[1] || cardNos[i] || ''
        
        records.push({
          timestamp: now,
          nickname: nickname,
          phone: phone,
          payment_key: key || '',
          item: itemName,
          card_no: cardNoFromItem,
          quantity: quantity || 0,
          total: total || 0,
          amount: amount || 0,
          remark: remark || '',
          status: status || 'pending',
          order_type: 'order',
          created_at: now
        })
      }
    }
    
    if (records.length > 0) {
      await supabase.insert('payment_records', records)
    }
    
    console.log(`[PAYMENT_NOTIFICATION] æˆåŠŸå»ºç«‹ ${records.length} ç­†ä»˜æ¬¾è¨˜éŒ„`)
    
    return { success: true }
    
  } catch (error) {
    console.error('[PAYMENT_NOTIFICATION] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

/**
 * å€‹äººè³‡æ–™æ›´æ–°é€šçŸ¥
 */
async function handleNotifyProfileUpdate(body, supabase) {
  const { nickname, phone, email, shipStore, storeNumber, address } = body
  console.log(`[PROFILE_UPDATE] ${nickname} æ›´æ–°å€‹äººè³‡æ–™`)
  
  try {
    // æ›´æ–°ç”¨æˆ¶è³‡æ–™
    const updates = {}
    if (email !== undefined) updates.email = email
    if (shipStore !== undefined) updates.ship_store = shipStore
    if (storeNumber !== undefined) updates.store_number = storeNumber
    if (address !== undefined) updates.address = address
    
    await supabase.update('users', { phone }, updates)
    
    console.log(`[PROFILE_UPDATE] æˆåŠŸæ›´æ–°ç”¨æˆ¶è³‡æ–™`)
    
    // TODO: ç™¼é€ email é€šçŸ¥ç®¡ç†å“¡
    
    return { success: true }
    
  } catch (error) {
    console.error('[PROFILE_UPDATE] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

/**
 * æŸ¥è©¢è¨‚å–®ç‹€æ…‹
 * æ ¹æ“šé—œéµå­—æœå°‹è¨‚å–®
 */
async function handleLookupOrderStatus(body, supabase) {
  const { query } = body
  console.log(`[LOOKUP_ORDER] æœå°‹: ${query}`)
  
  if (!query || query.length < 2) {
    return { success: false, message: 'è«‹è¼¸å…¥è‡³å°‘2å€‹å­—å…ƒ' }
  }
  
  try {
    // æŸ¥è©¢æ‰€æœ‰è¨‚å–®ï¼ˆç°¡åŒ–ç‰ˆï¼šåœ¨ç¨‹å¼ä¸­éæ¿¾ï¼‰
    const allOrders = await supabase.queryAll('orders', {
      order: 'created_at.desc'
    })
    
    // éæ¿¾åŒ…å«é—œéµå­—çš„è¨‚å–®
    const results = allOrders.filter(order => {
      const searchText = `${order.nickname} ${order.phone} ${order.item} ${order.card_no}`.toLowerCase()
      return searchText.includes(query.toLowerCase())
    }).slice(0, 50)  // é™åˆ¶æœ€å¤š50ç­†
    
    const formattedResults = results.map(o => ({
      nickname: o.nickname,
      phone: o.phone,
      item: o.item,
      cardNo: o.card_no,
      quantity: o.quantity,
      total: o.total_fee,
      balance: o.balance,
      status: o.status,
      arrivalStatus: o.arrival_status,
      timestamp: o.created_at
    }))
    
    console.log(`[LOOKUP_ORDER] æ‰¾åˆ° ${formattedResults.length} ç­†çµæœ`)
    
    return {
      success: true,
      orders: formattedResults
    }
    
  } catch (error) {
    console.error('[LOOKUP_ORDER] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

// ============================================
// ğŸ“Œ åœ˜æ‹†é‡‘åŠŸèƒ½
// ============================================

/**
 * å–å¾—åœ˜æ‹†é‡‘é¤˜é¡
 */
async function handleGetBreakCredit(body, supabase) {
  const { nickname } = body
  console.log(`[GET_BREAK_CREDIT] æŸ¥è©¢åœ˜æ‹†é‡‘: ${nickname}`)
  
  try {
    // æŸ¥è©¢è©²ç”¨æˆ¶çš„æ‰€æœ‰åœ˜æ‹†é‡‘è¨˜éŒ„
    const records = await supabase.query('break_credits', {
      eq: { nickname }
    })
    
    if (!records || records.length === 0) {
      return {
        success: true,
        credit: 0,
        history: []
      }
    }
    
    let totalCredit = 0
    const history = []
    
    for (const record of records) {
      const creditAmount = parseFloat(record.credit_amount) || 0
      const usedAmount = parseFloat(record.used_amount) || 0
      const remainingAmount = creditAmount - usedAmount
      
      if (remainingAmount > 0) {
        totalCredit += remainingAmount
      }
      
      history.push({
        amount: creditAmount,
        usedAmount: usedAmount,
        remaining: remainingAmount,
        source: record.source || '',
        used: record.is_used === true,
        usedBreak: record.used_break || ''
      })
    }
    
    console.log(`[GET_BREAK_CREDIT] åœ˜æ‹†é‡‘é¤˜é¡: ${totalCredit}`)
    
    return {
      success: true,
      credit: totalCredit,
      history: history
    }
    
  } catch (error) {
    console.error('[GET_BREAK_CREDIT] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

/**
 * ä½¿ç”¨åœ˜æ‹†é‡‘
 */
async function handleUseBreakCredit(body, supabase) {
  const { nickname, amount, breakIds } = body
  console.log(`[USE_BREAK_CREDIT] ${nickname} ä½¿ç”¨ ${amount} å…ƒåœ˜æ‹†é‡‘`)
  
  try {
    // æŸ¥è©¢ç”¨æˆ¶çš„åœ˜æ‹†é‡‘è¨˜éŒ„
    const records = await supabase.query('break_credits', {
      eq: { nickname },
      order: 'created_at.asc'  // æŒ‰æ™‚é–“é †åºä½¿ç”¨
    })
    
    if (!records || records.length === 0) {
      return { success: false, message: 'æ²’æœ‰å¯ç”¨çš„åœ˜æ‹†é‡‘' }
    }
    
    let remainingToUse = amount
    const updates = []
    
    // ä¾åºæ‰£é™¤åœ˜æ‹†é‡‘
    for (const record of records) {
      if (remainingToUse <= 0) break
      
      const creditAmount = parseFloat(record.credit_amount) || 0
      const alreadyUsed = parseFloat(record.used_amount) || 0
      const available = creditAmount - alreadyUsed
      
      if (available > 0) {
        const toUse = Math.min(available, remainingToUse)
        const newUsedAmount = alreadyUsed + toUse
        
        updates.push({
          id: record.id,
          newUsedAmount: newUsedAmount,
          isFullyUsed: newUsedAmount >= creditAmount,
          breakIds: breakIds
        })
        
        remainingToUse -= toUse
      }
    }
    
    if (remainingToUse > 0) {
      return { success: false, message: 'åœ˜æ‹†é‡‘ä¸è¶³' }
    }
    
    // åŸ·è¡Œæ›´æ–°
    for (const update of updates) {
      await supabase.update('break_credits',
        { id: update.id },
        {
          used_amount: update.newUsedAmount,
          is_used: update.isFullyUsed,
          used_break: update.breakIds
        }
      )
    }
    
    // è¨ˆç®—å‰©é¤˜åœ˜æ‹†é‡‘
    const afterRecords = await supabase.query('break_credits', {
      eq: { nickname }
    })
    
    let remainingCredit = 0
    for (const record of afterRecords) {
      const creditAmount = parseFloat(record.credit_amount) || 0
      const usedAmount = parseFloat(record.used_amount) || 0
      remainingCredit += (creditAmount - usedAmount)
    }
    
    console.log(`[USE_BREAK_CREDIT] ä½¿ç”¨æˆåŠŸï¼Œå‰©é¤˜: ${remainingCredit}`)
    
    return {
      success: true,
      remainingCredit: remainingCredit
    }
    
  } catch (error) {
    console.error('[USE_BREAK_CREDIT] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}
}

// ============================================
// ğŸ“Œ PSA é‘‘å®šåŠŸèƒ½ï¼ˆæš«ä¸å¯¦ä½œï¼‰
// ============================================

async function handleSubmitPsaOrder(body, supabase) {
  // PSA åŠŸèƒ½æš«ä¸ç§»æ¤
  return { success: false, message: 'PSA åŠŸèƒ½æš«ä¸æä¾›' }
}

async function handleLookupPsaOrders(body, supabase) {
  // PSA åŠŸèƒ½æš«ä¸ç§»æ¤
  return { success: false, message: 'PSA åŠŸèƒ½æš«ä¸æä¾›' }
}

// ============================================
// ğŸ“Œ æ¯æ—¥é‹å‹¢åŠŸèƒ½
// ============================================

/**
 * æª¢æŸ¥ä»Šæ—¥æ˜¯å¦å·²æŠ½éé‹å‹¢
 */
async function handleCheckDailyFortune(body, supabase) {
  const { phone } = body
  console.log(`[CHECK_FORTUNE] æª¢æŸ¥é‹å‹¢: ${phone}`)
  
  try {
    const today = new Date().toISOString().split('T')[0]  // YYYY-MM-DD
    
    // æŸ¥è©¢ä»Šå¤©çš„é‹å‹¢è¨˜éŒ„
    const records = await supabase.query('daily_fortune', {
      eq: { phone }
    })
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ä»Šå¤©çš„è¨˜éŒ„
    const todayRecord = records.find(r => {
      const recordDate = new Date(r.fortune_date).toISOString().split('T')[0]
      return recordDate === today
    })
    
    if (todayRecord) {
      console.log(`[CHECK_FORTUNE] ä»Šæ—¥å·²æŠ½é`)
      return {
        success: true,
        drawnToday: true,
        result: todayRecord.fortune_result
      }
    }
    
    console.log(`[CHECK_FORTUNE] ä»Šæ—¥å°šæœªæŠ½ç±¤`)
    return {
      success: true,
      drawnToday: false
    }
    
  } catch (error) {
    console.error('[CHECK_FORTUNE] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

/**
 * å„²å­˜ä»Šæ—¥é‹å‹¢
 */
async function handleSaveDailyFortune(body, supabase) {
  const { phone, nickname, result } = body
  console.log(`[SAVE_FORTUNE] å„²å­˜é‹å‹¢: ${nickname}`)
  
  try {
    const today = new Date().toISOString().split('T')[0]
    
    // æ–°å¢é‹å‹¢è¨˜éŒ„
    await supabase.insert('daily_fortune', {
      phone: phone,
      nickname: nickname,
      fortune_date: today,
      fortune_result: result,
      created_at: new Date().toISOString()
    })
    
    console.log(`[SAVE_FORTUNE] å„²å­˜æˆåŠŸ`)
    
    return { success: true }
    
  } catch (error) {
    console.error('[SAVE_FORTUNE] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

// ============================================
// ğŸ“Œ å‡ºè²¨åŠŸèƒ½
// ============================================

/**
 * å»ºç«‹å‡ºè²¨è¨˜éŒ„
 */
async function handleCreateShipmentRecord(body, supabase) {
  const { phone, nickname, items, trackingNumber, shippingFee } = body
  console.log(`[CREATE_SHIPMENT] å»ºç«‹å‡ºè²¨è¨˜éŒ„: ${nickname}`)
  
  try {
    const now = new Date().toISOString()
    
    // å»ºç«‹å‡ºè²¨è¨˜éŒ„
    const shipmentRecord = {
      phone: phone,
      nickname: nickname,
      tracking_number: trackingNumber || '',
      shipping_fee: parseFloat(shippingFee) || 0,
      shipped_at: now,
      created_at: now
    }
    
    const inserted = await supabase.insert('shipment_records', shipmentRecord)
    const shipmentId = inserted[0].id
    
    // æ›´æ–°è¨‚å–®ç‹€æ…‹ç‚ºã€Œå·²å¯„å‡ºã€
    if (items && items.length > 0) {
      for (const item of items) {
        try {
          // æŸ¥è©¢è©²ç­†è¨‚å–®
          const orders = await supabase.query('orders', {
            eq: {
              phone: phone,
              item: item.item,
              card_no: item.cardNo
            }
          })
          
          // æ›´æ–°ç‹€æ…‹
          for (const order of orders) {
            await supabase.update('orders',
              { id: order.id },
              {
                arrival_status: 'å·²å¯„å‡º',
                shipment_id: shipmentId
              }
            )
          }
        } catch (error) {
          console.error(`[CREATE_SHIPMENT] æ›´æ–°è¨‚å–®å¤±æ•—:`, error)
        }
      }
    }
    
    console.log(`[CREATE_SHIPMENT] å‡ºè²¨è¨˜éŒ„å»ºç«‹æˆåŠŸ #${shipmentId}`)
    
    // TODO: ç™¼é€å‡ºè²¨é€šçŸ¥ email
    
    return {
      success: true,
      shipmentId: shipmentId
    }
    
  } catch (error) {
    console.error('[CREATE_SHIPMENT] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

/**
 * å–å¾—å‡ºè²¨è¨˜éŒ„
 */
async function handleGetShipmentRecords(body, supabase) {
  const { phone } = body
  console.log(`[GET_SHIPMENT] æŸ¥è©¢å‡ºè²¨è¨˜éŒ„: ${phone}`)
  
  try {
    const records = await supabase.query('shipment_records', {
      eq: { phone },
      order: 'shipped_at.desc'
    })
    
    const formattedRecords = records.map(r => ({
      trackingNumber: r.tracking_number,
      shippingFee: r.shipping_fee,
      shippedAt: r.shipped_at,
      items: []  // TODO: é—œè¯è¨‚å–®é …ç›®
    }))
    
    console.log(`[GET_SHIPMENT] æ‰¾åˆ° ${formattedRecords.length} ç­†å‡ºè²¨è¨˜éŒ„`)
    
    return {
      success: true,
      records: formattedRecords
    }
    
  } catch (error) {
    console.error('[GET_SHIPMENT] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}
}

// ============================================
// ğŸ“Œ ç¶ ç•Œé‡‘æµåŠŸèƒ½ï¼ˆæš«ä¸å¯¦ä½œï¼‰
// ============================================

async function handleCreateEcpayPayment(body, supabase) {
  // ç¶ ç•Œé‡‘æµæ•´åˆè¼ƒè¤‡é›œï¼Œæš«ä¸å¯¦ä½œ
  // éœ€è¦ HashKeyã€HashIV ç­‰æ•æ„Ÿè³‡è¨Š
  return { success: false, message: 'ç¶ ç•Œé‡‘æµåŠŸèƒ½æš«ä¸æä¾›' }
}

async function handleCheckPaymentStatus(body, supabase) {
  // ç¶ ç•Œé‡‘æµæ•´åˆè¼ƒè¤‡é›œï¼Œæš«ä¸å¯¦ä½œ
  return { success: false, message: 'ç¶ ç•Œé‡‘æµåŠŸèƒ½æš«ä¸æä¾›' }
}

async function handleUpdateOrderStatusToPending(body, supabase) {
  const { orderDetails, merchantTradeNo } = body
  console.log(`[UPDATE_ORDER_PENDING] æ›´æ–°è¨‚å–®ç‹€æ…‹`)
  
  try {
    // æ›´æ–°è¨‚å–®ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
    if (orderDetails && orderDetails.length > 0) {
      for (const detail of orderDetails) {
        const orders = await supabase.query('orders', {
          eq: {
            phone: detail.phone,
            item: detail.item,
            card_no: detail.cardNo
          }
        })
        
        for (const order of orders) {
          await supabase.update('orders',
            { id: order.id },
            {
              status: 'ä»˜æ¬¾ç¢ºèªä¸­',
              payment_trade_no: merchantTradeNo
            }
          )
        }
      }
    }
    
    return { success: true }
    
  } catch (error) {
    console.error('[UPDATE_ORDER_PENDING] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

async function handleUpdateBreakStatusToPending(body, supabase) {
  const { breakDetails, merchantTradeNo } = body
  console.log(`[UPDATE_BREAK_PENDING] æ›´æ–°åœ˜æ‹†ç‹€æ…‹`)
  
  try {
    // æ›´æ–°åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
    if (breakDetails && breakDetails.length > 0) {
      for (const detail of breakDetails) {
        await supabase.update('break_credits',
          { break_id: detail.breakId },
          {
            status: 'ä»˜æ¬¾ç¢ºèªä¸­',
            payment_trade_no: merchantTradeNo
          }
        )
      }
    }
    
    return { success: true }
    
  } catch (error) {
    console.error('[UPDATE_BREAK_PENDING] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}

// ============================================
// ğŸ“Œ è³‡æ–™é©—è­‰åŠŸèƒ½
// ============================================

async function handleVerifyData(body, supabase) {
  console.log('[VERIFY_DATA] é–‹å§‹é©—è­‰è³‡æ–™')
  
  try {
    const report = {
      users: 0,
      products: 0,
      orders: 0,
      breakCredits: 0,
      errors: []
    }
    
    // çµ±è¨ˆç”¨æˆ¶æ•¸é‡
    const users = await supabase.query('users', {})
    report.users = users.length
    
    // çµ±è¨ˆå•†å“æ•¸é‡
    const products = await supabase.query('product_catalog', {})
    report.products = products.length
    
    // çµ±è¨ˆè¨‚å–®æ•¸é‡
    const orders = await supabase.queryAll('orders', {})
    report.orders = orders.length
    
    // çµ±è¨ˆåœ˜æ‹†é‡‘è¨˜éŒ„
    const breaks = await supabase.query('break_credits', {})
    report.breakCredits = breaks.length
    
    // é©—è­‰è³‡æ–™å®Œæ•´æ€§
    let invalidOrders = 0
    for (const order of orders) {
      if (!order.phone || !order.item) {
        invalidOrders++
      }
    }
    
    if (invalidOrders > 0) {
      report.errors.push(`ç™¼ç¾ ${invalidOrders} ç­†è¨‚å–®ç¼ºå°‘å¿…è¦æ¬„ä½`)
    }
    
    console.log('[VERIFY_DATA] é©—è­‰å®Œæˆ:', report)
    
    return {
      success: true,
      report: report
    }
    
  } catch (error) {
    console.error('[VERIFY_DATA] éŒ¯èª¤:', error)
    return { success: false, message: error.message }
  }
}
}

// ============================================
// ğŸ“Œ Worker å…¥å£é»
// ============================================

export default {
  async fetch(request, env) {
    const url = new URL(request.url)
    
    // CORS é æª¢
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type'
        }
      })
    }
    
    // API è«‹æ±‚
    if (request.method === 'POST' && url.pathname === '/api') {
      return handleAPI(request, env)
    }
    
    // æ‰€æœ‰å…¶ä»–è«‹æ±‚è¿”å›ç°¡å–®çš„æ¸¬è©¦é é¢
    // ğŸŒŸ GET æ ¹è·¯å¾‘ - è¿”å›å®Œæ•´çš„ç¶²ç«™å‰ç«¯
    return new Response(HTML_CONTENT, {
      headers: { 
        'Content-Type': 'text/html; charset=utf-8',
        'Cache-Control': 'no-cache'
      }
    })
  }
}
