// ==================== å¾Œç«¯ API è™•ç† ====================

class SupabaseClient {
  constructor(url, apiKey) {
    this.url = url;
    this.apiKey = apiKey;
  }
  
  async query(table, options = {}) {
    const { select = '*', eq = {}, or = null, order = null, range = null, count = false } = options;
    let queryUrl = `${this.url}/rest/v1/${table}?select=${select}`;
    for (const [key, value] of Object.entries(eq)) {
      queryUrl += `&${key}=eq.${encodeURIComponent(value)}`;
    }
    if (or) queryUrl += `&or=(${or})`;
    if (order) queryUrl += `&order=${order.column}.${order.ascending ? 'asc' : 'desc'}`;
    if (range) queryUrl += `&limit=${range[1] - range[0] + 1}&offset=${range[0]}`;
    const headers = {
      'apikey': this.apiKey,
      'Authorization': `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json',
      'Prefer': count ? 'count=exact' : ''
    };
    const response = await fetch(queryUrl, { headers });
    return await response.json();
  }
  
  async insert(table, data) {
    const response = await fetch(`${this.url}/rest/v1/${table}`, {
      method: 'POST',
      headers: {
        'apikey': this.apiKey,
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify(data)
    });
    
    // ğŸ”§ ä¿®æ­£ï¼šæª¢æŸ¥å›æ‡‰æ˜¯å¦æˆåŠŸï¼Œè™•ç†é JSON éŒ¯èª¤
    if (!response.ok) {
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        const error = await response.json();
        console.error('[INSERT] Supabase éŒ¯èª¤:', error);
        throw new Error(error.message || `Insert failed: ${response.statusText}`);
      } else {
        const errorText = await response.text();
        console.error('[INSERT] Supabase éŒ¯èª¤ (éJSON):', errorText);
        throw new Error(`Insert failed: ${errorText || response.statusText}`);
      }
    }
    
    return await response.json();
  }
  
  // ğŸŒŸ æŸ¥è©¢æ‰€æœ‰è³‡æ–™ï¼ˆç„¡é™åˆ¶ï¼‰ï¼Œç”¨æ–¼ç´¯ç©å¼µæ•¸è¨ˆç®—ç­‰
  async queryAll(table, options = {}) {
    const { select = '*', eq = {}, order = null } = options;

    const buildUrl = (selectValue, limit, offset) => {
      let queryUrl = `${this.url}/rest/v1/${table}?select=${selectValue}`;
      for (const [key, value] of Object.entries(eq)) {
        queryUrl += `&${key}=eq.${encodeURIComponent(value)}`;
      }
      if (order) queryUrl += `&order=${order.column}.${order.ascending ? 'asc' : 'desc'}`;
      if (limit != null) queryUrl += `&limit=${limit}`;
      if (offset != null) queryUrl += `&offset=${offset}`;
      return queryUrl;
    };

    const headers = {
      'apikey': this.apiKey,
      'Authorization': `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'count=exact'
    };

    const pageSize = 1000;
    let offset = 0;
    let total = null;
    const allRows = [];

    while (true) {
      let response = await fetch(buildUrl(select, pageSize, offset), { headers });

      if (!response.ok && response.status === 400) {
        const errorText = await response.text();
        console.error('[queryAll] Bad Request:', errorText);
        const fallbackSelect = select !== '*' ? '*' : 'item,card_no,quantity';
        response = await fetch(buildUrl(fallbackSelect, pageSize, offset), { headers });
      }

      if (!response.ok) {
        const errorText = await response.text();
        console.error('[queryAll] Error:', response.status, errorText);
        throw new Error(`Supabase queryAll failed: ${response.statusText}`);
      }

      const contentRange = response.headers.get('Content-Range');
      if (contentRange) {
        console.log('[queryAll] Content-Range:', contentRange);
        const totalMatch = contentRange.match(/\/(\d+)$/);
        if (totalMatch) total = parseInt(totalMatch[1], 10);
      }

      const rows = await response.json();
      if (Array.isArray(rows) && rows.length > 0) {
        allRows.push(...rows);
      }

      if (!Array.isArray(rows) || rows.length < pageSize) break;
      if (total != null && allRows.length >= total) break;

      offset += pageSize;
    }

    return allRows;
  }
}

function parseBoolValue(value) {
  if (value === true || value === false) return value;
  const text = String(value || '').trim().toLowerCase();
  return text === 'true' || text === 'y' || text === 'yes' || text === '1' || text === 'æ˜¯';
}

/**
 * ğŸ• å–å¾—å°ç£æ™‚é–“ (UTC+8)
 * @returns {Date} å°ç£æ™‚é–“çš„ Date ç‰©ä»¶
 */
function getTaiwanTime() {
  const now = new Date();
  const taiwanOffset = 8 * 60; // å°ç£ UTC+8ï¼Œåˆ†é˜æ•¸
  return new Date(now.getTime() + taiwanOffset * 60 * 1000);
}

/**
 * ğŸ• å–å¾—å°ç£æ™‚é–“çš„ ISO å­—ä¸²
 * @returns {string} å°ç£æ™‚é–“çš„ ISO æ ¼å¼å­—ä¸²
 */
function getTaiwanTimeISO() {
  return getTaiwanTime().toISOString();
}

// ==================== Supabase é è¨­è¨­å®š (æ¸¬è©¦ç”¨) ====================
const DEFAULT_SUPABASE_URL = 'https://hmqwcpstzkxfwabasqgx.supabase.co';
const DEFAULT_SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhtcXdjcHN0emt4ZndhYmFzcWd4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk0MTM1OTgsImV4cCI6MjA4NDk4OTU5OH0.UJWsWXL-1_L6cGsmoBVSlsYlEEGMSp1F_wyXAc1hB8E';

// ==================== ğŸ’³ ç¶ ç•Œé‡‘æµè¨­å®š (æ¸¬è©¦ç’°å¢ƒ) ====================
const ECPAY_CONFIG = {
  MerchantID: '3002607',                 // æ¸¬è©¦ç’°å¢ƒç‰¹åº—ç·¨è™Ÿ
  HashKey: 'pwFHCqoQZGmho4w6',           // æ¸¬è©¦ç’°å¢ƒ HashKey
  HashIV: 'EkRm7iFT261dpevs',            // æ¸¬è©¦ç’°å¢ƒ HashIV
  PaymentURL: 'https://payment-stage.ecpay.com.tw/Cashier/AioCheckOut/V5',
  QueryURL: 'https://payment-stage.ecpay.com.tw/Cashier/QueryTradeInfo/V5',
  ChoosePayment: 'Credit',               // åªé–‹æ”¾ä¿¡ç”¨å¡ä»˜æ¬¾
  EncryptType: 1
};

// ==================== è³‡æ–™æ­£è¦åŒ–å·¥å…· ====================
function normalizeText(value) {
  return String(value || '')
    .replace(/\u3000/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();
}

function normalizeCardNo(value) {
  const text = normalizeText(value);
  if (!text) return '';
  if (/^\d+$/.test(text)) {
    return String(parseInt(text, 10));
  }
  const match = text.match(/\d+/);
  if (match && match[0]) {
    return String(parseInt(match[0], 10));
  }
  return text;
}

function buildKey(item, cardNo) {
  const itemKey = normalizeText(item);
  const cardKey = normalizeCardNo(cardNo);
  return itemKey + '||' + cardKey;
}

function buildItemKey(item) {
  return normalizeText(item);
}

async function fetchAllOrdersForAccumulation(supabase) {
  const sources = [
    { table: 'orders', select: 'item,card_no,quantity' }
  ];

  for (const source of sources) {
    try {
      const rows = await supabase.queryAll(source.table, { select: source.select });
      if (Array.isArray(rows) && rows.length > 0) {
        console.log('[ACCUM] ä½¿ç”¨è¨‚å–®ä¾†æº:', source.table, 'ç­†æ•¸:', rows.length);
        return { table: source.table, rows };
      }
      if (Array.isArray(rows)) {
        console.log('[ACCUM] è¨‚å–®ä¾†æºç„¡è³‡æ–™:', source.table);
      }
    } catch (error) {
      console.error('[ACCUM] è®€å–è¨‚å–®ä¾†æºå¤±æ•—:', source.table, error);
    }
  }

  return { table: null, rows: [] };
}

async function handleAPI(request, env) {
  try {
    const body = await request.json();
    const { action } = body;
    
    // ğŸ“Š è¨˜éŒ„æ‰€æœ‰ action
    console.log('[API] æ”¶åˆ° action:', action);
    console.log('[API] å®Œæ•´ body:', JSON.stringify(body).substring(0, 200));
    
    if (action === 'createEcpayPayment') {
      console.log('[API] â­ createEcpayPayment å·²åµæ¸¬ï¼åƒæ•¸:', {
        phone: body.phone,
        totalAmount: body.totalAmount,
        itemName: body.itemName
      });
    }
    
    if (action === 'addBreaksBatch') {
      console.log('[API] â­ addBreaksBatch å·²åµæ¸¬ï¼breaks æ•¸é‡:', body.breaks?.length);
    }
    
    const supabaseUrl = env.SUPABASE_URL || DEFAULT_SUPABASE_URL;
    const supabaseKey = env.SUPABASE_ANON_KEY || DEFAULT_SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseKey) {
      return {
        success: false,
        message: 'ç¼ºå°‘ SUPABASE_URL æˆ– SUPABASE_ANON_KEY ç’°å¢ƒè®Šæ•¸'
      };
    }

    const supabase = new SupabaseClient(supabaseUrl, supabaseKey);
    
    let result;
    switch (action) {
      case 'login': result = await handleLogin(body, supabase); break;
      case 'registerUser': result = await handleRegisterUser(body, supabase); break;
      case 'getOrderCatalog':
      case 'getProducts': result = await handleGetProducts(body, supabase); break;
      case 'getOrderInfo': result = await handleGetOrderInfo(body, supabase); break;
      case 'addOrderEntriesToMain': result = await handleAddOrder(body, supabase); break;
      case 'getPendingPaymentKeys': result = await handleGetPendingPaymentKeys(body, supabase); break;
      case 'notifyPaymentBulk': result = await handleNotifyPaymentBulk(body, supabase); break;
      case 'submitPaymentNotification': result = await handlePaymentNotification(body, supabase); break;
      case 'notifyProfileUpdate': result = await handleNotifyProfileUpdate(body, supabase); break;
      case 'lookupOrderStatus': result = await handleLookupOrderStatus(body, supabase); break;
      case 'getBreakCredit': result = await handleGetBreakCredit(body, supabase); break;
      case 'useBreakCredit': result = await handleUseBreakCredit(body, supabase); break;
      case 'submitPsaOrder': result = await handleSubmitPsaOrder(body, supabase); break;
      case 'lookupPsaOrders': result = await handleLookupPsaOrders(body, supabase); break;
      case 'checkDailyFortune': result = await handleCheckDailyFortune(body, supabase); break;
      case 'saveDailyFortune': result = await handleSaveDailyFortune(body, supabase); break;
      case 'createShipmentRecord': result = await handleCreateShipmentRecord(body, supabase); break;
      case 'getShipmentRecords': result = await handleGetShipmentRecords(body, supabase); break;
      case 'createEcpayPayment': result = await handleCreateEcpayPayment(body, supabase); break;
      case 'checkPaymentStatus': result = await handleCheckPaymentStatus(body, supabase); break;
      case 'updateOrderStatusToPending': result = await handleUpdateOrderStatusToPending(body, supabase); break;
      case 'updateBreakStatusToPending': result = await handleUpdateBreakStatusToPending(body, supabase); break;
      case 'updateOrderStatusToFailed': result = await handleUpdateOrderStatusToFailed(body, supabase); break;
      case 'verifyData': result = await handleVerifyData(body, supabase); break;
      case 'debugAccum': result = await handleDebugAccum(body, supabase); break;
      // ğŸŒŸ å¾Œå°ç®¡ç† API
      case 'adminLogin': result = await handleAdminLogin(body, supabase); break;
      case 'getNotifications': result = await handleGetNotifications(body, supabase); break;
      case 'updateNotification': result = await handleUpdateNotification(body, supabase); break;
      case 'deleteNotification': result = await handleDeleteNotification(body, supabase); break;
      case 'searchOrders': result = await handleSearchOrders(body, supabase); break;
      case 'updateOrder': result = await handleUpdateOrder(body, supabase); break;
      case 'getAllBreaks': result = await handleGetAllBreaks(body, supabase); break;
      case 'updateBreak': result = await handleUpdateBreak(body, supabase); break;
      case 'deleteBreak': result = await handleDeleteBreak(body, supabase); break;
      case 'addBreaksBatch': result = await handleAddBreaksBatch(body, supabase); break;
      case 'getAllOrders': result = await handleGetAllOrders(body, supabase); break;
      case 'deleteOrder': result = await handleDeleteOrder(body, supabase); break;
      case 'getUsers': result = await handleGetUsers(body, supabase); break;
      case 'searchUsers': result = await handleSearchUsers(body, supabase); break;
      case 'updateUser': result = await handleUpdateUser(body, supabase); break;
      case 'addProduct': result = await handleAddProduct(body, supabase); break;
      case 'cleanupDuplicateUsers': result = await handleCleanupDuplicateUsers(body, supabase); break;
      // ğŸŒŸ å•†å“ç®¡ç† API
      case 'getAllProducts': result = await handleGetAllProducts(body, supabase); break;
      case 'updateProduct': result = await handleUpdateProduct(body, supabase); break;
      case 'deleteProduct': result = await handleDeleteProduct(body, supabase); break;
      // ğŸŒŸ åœ˜æ‹†é‡‘ç®¡ç† API
      case 'getAllBreakCredits': result = await handleGetAllBreakCredits(body, supabase); break;
      case 'addBreakCredit': result = await handleAddBreakCredit(body, supabase); break;
      case 'batchAddBreakCredit': result = await handleBatchAddBreakCredit(body, supabase); break;
      case 'updateBreakCredit': result = await handleUpdateBreakCredit(body, supabase); break;
      case 'deleteBreakCredit': result = await handleDeleteBreakCredit(body, supabase); break;
      // ğŸŒŸ å‡ºè²¨ç®¡ç† API
      case 'generateShippingReport': result = await handleGenerateShippingReport(body, supabase); break;
      case 'debugUserOrders': result = await handleDebugUserOrders(body, supabase); break;
      case 'createShipment': result = await handleCreateShipment(body, supabase); break;
      case 'getAllShipments': result = await handleGetAllShipments(body, supabase); break;
      case 'batchUpdateTrackingNumbers': result = await handleBatchUpdateTrackingNumbers(body, supabase); break;
      case 'deleteShipment': result = await handleDeleteShipment(body, supabase); break;
      default: 
        console.error('[API] âŒ æœªçŸ¥çš„ action:', action);
        console.log('[API] å¯ç”¨çš„ actions:', [
          'login', 'registerUser', 'getProducts', 'getOrderInfo', 'addOrderEntriesToMain',
          'createEcpayPayment', 'checkPaymentStatus', 'submitPaymentNotification',
          'adminLogin', 'getNotifications', 'updateNotification', 'searchOrders', 'updateOrder',
          'getAllBreaks', 'updateBreak', 'addBreaksBatch', 'getUsers', 'searchUsers', 'updateUser'
        ]);
        result = { success: false, message: `æœªçŸ¥çš„ action: ${action}` };
    }
    
    return new Response(JSON.stringify(result), {
      status: 200,  // ç¸½æ˜¯è¿”å› 200ï¼Œç”± result.success æ±ºå®šé‚è¼¯æˆåŠŸæˆ–å¤±æ•—
      headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
    });
  } catch (error) {
    console.error('[API] è™•ç† action æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
    return new Response(JSON.stringify({ 
      success: false, 
      message: error.message || 'ä¼ºæœå™¨å…§éƒ¨éŒ¯èª¤'
    }), {
      status: 200,  // å³ä½¿å‡ºéŒ¯ä¹Ÿè¿”å› 200ï¼Œè®“å‰ç«¯èƒ½è®€åˆ°éŒ¯èª¤è¨Šæ¯
      headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
    });
  }
}

async function handleDebugAccum(body, supabase) {
  const { item, cardNo } = body;
  if (!item) {
    return { success: false, message: 'ç¼ºå°‘ item' };
  }

  const { table, rows } = await fetchAllOrdersForAccumulation(supabase);
  const targetKey = buildKey(item, cardNo);
  const targetItemKey = buildItemKey(item);

  let accumulated = 0;
  let matchedRows = 0;
  const sampleRows = [];
  const sampleMatches = [];

  if (Array.isArray(rows)) {
    rows.forEach(order => {
      const orderItem = order.item || order.item_name || order.product_name || '';
      const orderCard = order.card_no || order.cardno || '';
      const key = buildKey(orderItem, orderCard);
      const itemKey = buildItemKey(orderItem);
      const qty = parseInt(order.quantity) || 0;

      if (qty <= 0) return;

      if (sampleRows.length < 3) {
        sampleRows.push({ item: orderItem, cardNo: orderCard, quantity: qty, key });
      }

      if (key === targetKey || itemKey === targetItemKey) {
        accumulated += qty;
        matchedRows += 1;
        if (sampleMatches.length < 3) {
          sampleMatches.push({ item: orderItem, cardNo: orderCard, quantity: qty, key });
        }
      }
    });
  }

  return {
    success: true,
    table: table || 'none',
    targetKey,
    targetItemKey,
    totalRows: Array.isArray(rows) ? rows.length : 0,
    accumulated,
    matchedRows,
    sampleRows,
    sampleMatches
  };
}

async function handleLogin(body, supabase) {
  const { phone, birthday } = body;
  console.log('[LOGIN] Attempt: phone=' + phone + ', birthday=' + birthday);
  
  const users = await supabase.query('users', { eq: { phone } });
  console.log('[LOGIN] Users query result:', JSON.stringify(users));
  
  if (!Array.isArray(users) || users.length === 0) {
    console.log('[LOGIN] ERROR: Phone not found: ' + phone);
    return { success: false, message: 'é›»è©±è™Ÿç¢¼æˆ–ç”Ÿæ—¥éŒ¯èª¤' }; // ä¸é€éœ²å…·é«”æ˜¯å“ªå€‹éŒ¯èª¤
  }
  
  const user = users[0];
  console.log('[LOGIN] User found:', JSON.stringify(user));
  
  // ğŸ”’ åš´æ ¼é©—è­‰ç”Ÿæ—¥
  const userBirthday = String(user.birthday || '').trim();
  const inputBirthday = String(birthday || '').trim();
  
  console.log('[LOGIN] Birthday comparison:');
  console.log('[LOGIN] - DB birthday:', userBirthday);
  console.log('[LOGIN] - Input birthday:', inputBirthday);
  
  // ğŸ”‘ åš´æ ¼æ¯”å°ç”Ÿæ—¥ï¼Œå¿…é ˆå®Œå…¨ä¸€è‡´
  if (userBirthday !== inputBirthday) {
    console.log('[LOGIN] ERROR: Birthday mismatch');
    console.log('[LOGIN] - Expected:', userBirthday, '(length:', userBirthday.length + ')');
    console.log('[LOGIN] - Got:', inputBirthday, '(length:', inputBirthday.length + ')');
    return { success: false, message: 'é›»è©±è™Ÿç¢¼æˆ–ç”Ÿæ—¥éŒ¯èª¤' }; // ä¸é€éœ²å…·é«”æ˜¯å“ªå€‹éŒ¯èª¤
  }
  
  console.log('[LOGIN] âœ… SUCCESS for ' + phone);
  return { success: true, user };
}

async function handleRegisterUser(body, supabase) {
  try {
    let { phone, nickname, birthday, email, address, realName, storeNumber } = body;
    
    console.log('ğŸ“ è¨»å†Šè³‡æ–™:', { phone, nickname, birthday, realName, address, storeNumber });
    
    // ğŸ”‘ ç¢ºä¿æ‰‹æ©Ÿè™Ÿç¢¼æœ‰é–‹é ­ 0
    if (phone && !phone.startsWith('0')) {
      phone = '0' + phone;
      console.log('âœ… å·²è‡ªå‹•åŠ ä¸Šæ‰‹æ©Ÿè™Ÿç¢¼é–‹é ­ 0:', phone);
    }
    
    // é©—è­‰æ‰‹æ©Ÿè™Ÿç¢¼æ ¼å¼ï¼ˆ0 é–‹é ­çš„ 10 ä½æ•¸å­—ï¼‰
    if (!/^0\d{9}$/.test(phone)) {
      console.log('âŒ æ‰‹æ©Ÿè™Ÿç¢¼æ ¼å¼ä¸æ­£ç¢º:', phone);
      return { success: false, message: 'æ‰‹æ©Ÿè™Ÿç¢¼æ ¼å¼ä¸æ­£ç¢ºï¼Œè«‹è¼¸å…¥ 0 é–‹é ­çš„ 10 ä½æ•¸å­—' };
    }
    
    const existing = await supabase.query('users', { eq: { phone } });
    if (existing && existing.length > 0) {
      console.log('âŒ æ‰‹æ©Ÿè™Ÿç¢¼å·²å­˜åœ¨:', phone);
      return { success: false, message: 'æ­¤é›»è©±è™Ÿç¢¼å·²è¨»å†Š' };
    }
    
    // ğŸ”§ ä¿®æ­£ï¼šaddress æ˜¯é–€å¸‚åç¨±ï¼Œæ‡‰è©²å­˜åˆ° cvs_store_name
    const newUser = [{
      phone: phone,
      nickname: nickname || '',
      birthday: birthday || '',
      email: email || '',
      real_name: realName || '',
      cvs_store_name: address || '',      // ğŸ”‘ é–€å¸‚åç¨±
      cvs_store_id: storeNumber || ''     // ğŸ”‘ é–€å¸‚ç·¨è™Ÿ
    }];
    
    console.log('ğŸ’¾ æº–å‚™æ’å…¥ç”¨æˆ¶è³‡æ–™:', newUser);
    
    const result = await supabase.insert('users', newUser);
    console.log('âœ… æ’å…¥çµæœ:', result);
    
    if (result && result.length > 0) {
      return { success: true, message: 'è¨»å†ŠæˆåŠŸï¼', user: result[0] };
    }
    
    return { success: false, message: 'è¨»å†Šå¤±æ•—' };
  } catch (error) {
    console.error('âŒ è¨»å†ŠéŒ¯èª¤:', error);
    return { success: false, message: 'è¨»å†Šéç¨‹ç™¼ç”ŸéŒ¯èª¤: ' + error.message };
  }
}

async function handleGetProducts(body, supabase) {
  try {
    const products = await supabase.query('product_catalog', {});
    console.log('[PRODUCTS] Query returned ' + (Array.isArray(products) ? products.length : 'non-array') + ' items');
    
    if (!Array.isArray(products)) {
      console.error('[PRODUCTS] ERROR: Not an array:', products);
      return { success: false, message: `è³‡æ–™æ ¼å¼éŒ¯èª¤: ${JSON.stringify(products)}` };
    }
    
    if (products.length === 0) {
      return { success: true, items: [], message: 'è³‡æ–™åº«ä¸­æ²’æœ‰å•†å“è³‡æ–™' };
    }
    
    // è¨˜éŒ„ç¬¬ä¸€ç­†å•†å“çš„åŸå§‹è³‡æ–™
    console.log('[PRODUCTS] Sample product (first):', JSON.stringify(products[0]));
    
    // ğŸŒŸ å‹•æ…‹è¨ˆç®—æ¯å€‹å•†å“çš„ç´¯ç©å¼µæ•¸ï¼ˆå¾ orders è³‡æ–™è¡¨å¯¦æ™‚åŠ ç¸½ï¼‰
    console.log('[PRODUCTS] é–‹å§‹å‹•æ…‹è¨ˆç®—ç´¯ç©å¼µæ•¸...');
    const accumulatedMap = new Map();
    const accumulatedItemMap = new Map();
    
    try {
      // ğŸ”‘ ä½¿ç”¨ queryAll æŸ¥è©¢æ‰€æœ‰è¨‚å–®ï¼ˆç„¡é™åˆ¶ï¼‰
      const { rows: allOrders } = await fetchAllOrdersForAccumulation(supabase);
      
      console.log('[PRODUCTS] æŸ¥è©¢åˆ° ' + (Array.isArray(allOrders) ? allOrders.length : 0) + ' ç­†è¨‚å–®');
      
      if (Array.isArray(allOrders)) {
        // æŒ‰å•†å“åç¨±å’Œå¡è™Ÿåˆ†çµ„åŠ ç¸½
        allOrders.forEach((order, idx) => {
          const orderItem = order.item || order.item_name || order.product_name || '';
          const orderCard = order.card_no || order.cardno || '';
          const key = buildKey(orderItem, orderCard);
          const itemKey = buildItemKey(orderItem);
          const qty = parseInt(order.quantity) || 0;
          
          // é™¤éŒ¯ï¼šé¡¯ç¤ºå‰ 3 ç­†è¨‚å–®çš„åŸå§‹è³‡æ–™
          if (idx < 3) {
            console.log('[PRODUCTS] è¨‚å–® #' + idx + ': item="' + orderItem + '", card_no="' + orderCard + '", qty=' + qty + ', key="' + key + '"');
          }
          
          if (qty > 0 && itemKey) {
            accumulatedMap.set(key, (accumulatedMap.get(key) || 0) + qty);
            accumulatedItemMap.set(itemKey, (accumulatedItemMap.get(itemKey) || 0) + qty);
          }
        });
        console.log('[PRODUCTS] ç´¯ç©å¼µæ•¸è¨ˆç®—å®Œæˆï¼Œå…± ' + accumulatedMap.size + ' å€‹å•†å“æœ‰è¨‚å–®');
        
        // é¡¯ç¤ºå‰å¹¾å€‹å•†å“çš„ç´¯ç©å¼µæ•¸ï¼ˆç”¨æ–¼é™¤éŒ¯ï¼‰
        let count = 0;
        for (const [key, qty] of accumulatedMap) {
          if (count < 5) {
            console.log('[PRODUCTS] ç¯„ä¾‹ç´¯ç©: "' + key + '" = ' + qty + ' å¼µ');
            count++;
          } else {
            break;
          }
        }
      }
    } catch (error) {
      console.error('[PRODUCTS] è¨ˆç®—ç´¯ç©å¼µæ•¸å¤±æ•—:', error);
    }
    
    const items = products.map(p => {
      const isBox = parseBoolValue(p.is_box_preorder) ? 'Y' : 'N';
      
      // ğŸŒŸ å¾å‹•æ…‹è¨ˆç®—çš„ Map ç²å–ç´¯ç©å¼µæ•¸ï¼ˆä½¿ç”¨ç›¸åŒçš„æ¨™æº–åŒ–æ–¹å¼ï¼‰
      const key = buildKey(p.item_name, p.card_no);
      const itemKey = buildItemKey(p.item_name);
      const accumulated = (accumulatedMap.get(key) != null)
        ? accumulatedMap.get(key)
        : (accumulatedItemMap.get(itemKey) || 0);
      
      return {
        item: p.item_name,
        cardNo: p.card_no,
        price: p.price,
        discountPrice: p.threshold_price || p.price,
        fullPrice: p.threshold_price || p.price,
        threshold: p.discount_threshold || 0,
        images: [p.image_url_1, p.image_url_2, p.image_url_3, p.image_url_4].filter(Boolean),
        isBox: isBox,
        status: parseBoolValue(p.is_available) ? 'open' : 'closed',
        isOpen: parseBoolValue(p.is_available),
        stockStatus: p.stock_status || 'P',
        arrivalStatus: p.stock_status || 'P',
        stock: p.remaining_stock || 0,
        canDrawSp: parseBoolValue(p.can_draw_sp),
        canDrawSignature: parseBoolValue(p.can_draw_signature),
        canDrawRelic: parseBoolValue(p.can_draw_relic),
        canDrawAutoRelic: parseBoolValue(p.can_draw_auto_relic),
        minGroup: p.min_group_quantity || 0,
        category: p.category,
        isBoxPreorder: parseBoolValue(p.is_box_preorder),
        canDirectOrder: parseBoolValue(p.can_direct_order),
        isDirect: parseBoolValue(p.can_direct_order) ? 'Y' : 'N',
        closeTime: p.scheduled_delist_time || '',
        // ğŸŒŸ ç´¯ç©å¼µæ•¸ï¼ˆå‹•æ…‹è¨ˆç®—ï¼Œæ°¸é æº–ç¢ºï¼‰
        accumulatedCount: accumulated,
        description: p.description || ''
      };
    });
    
    const boxCount = items.filter(i => i.isBox === 'Y').length;
    const toppsCount = items.filter(i => i.isBox === 'N').length;
    console.log('[PRODUCTS] Converted ' + items.length + ' items: Boxes=' + boxCount + ', Topps=' + toppsCount);
    console.log('[PRODUCTS] Sample converted item:', JSON.stringify(items[0]));
    
    return { success: true, items };
  } catch (error) {
    console.error('[PRODUCTS] ERROR:', error);
    return { success: false, message: error.message };
  }
}

async function handleGetOrderInfo(body, supabase) {
  const { phone, birthday } = body;
  console.log('[ORDER_INFO] Getting order info for phone: ' + phone);
  
  // ğŸ”’ é©—è­‰å¿…é ˆæä¾›ç”Ÿæ—¥
  if (!birthday) {
    console.log('[ORDER_INFO] ERROR: Birthday not provided');
    return { success: false, message: 'è«‹æä¾›ç”Ÿæ—¥é€²è¡Œé©—è­‰' };
  }
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!Array.isArray(users) || users.length === 0) {
    console.log('[ORDER_INFO] ERROR: User not found: ' + phone);
    return { success: false, message: 'é›»è©±è™Ÿç¢¼æˆ–ç”Ÿæ—¥éŒ¯èª¤' };
  }
  
  const user = users[0];
  
  // ğŸ”’ åš´æ ¼é©—è­‰ç”Ÿæ—¥
  const userBirthday = String(user.birthday || '').trim();
  const inputBirthday = String(birthday || '').trim();
  
  if (userBirthday !== inputBirthday) {
    console.log('[ORDER_INFO] ERROR: Birthday mismatch');
    console.log('[ORDER_INFO] - Expected:', userBirthday);
    console.log('[ORDER_INFO] - Got:', inputBirthday);
    return { success: false, message: 'é›»è©±è™Ÿç¢¼æˆ–ç”Ÿæ—¥éŒ¯èª¤' };
  }
  
  const userId = user.id;
  const userNickname = user.nickname;
  console.log('[ORDER_INFO] âœ… Auth success - User ID: ' + userId + ', Nickname: ' + userNickname);
  
  // æŸ¥è©¢è¨‚å–®ï¼ˆä½¿ç”¨ orders è³‡æ–™è¡¨ï¼‰
  let orders = await supabase.query('orders', { eq: { user_id: userId }, order: { column: 'timestamp', ascending: false } });
  
  // æŸ¥è©¢åœ˜æ‹†è¨˜éŒ„ï¼ˆä½¿ç”¨ breaks è³‡æ–™è¡¨ï¼‰
  // åŒ…æ‹¬ï¼š1. ç”¨æˆ¶ç›´æ¥æ“æœ‰çš„åœ˜æ‹† (user_id åŒ¹é…)
  //      2. ç”¨æˆ¶ä½œç‚ºè¨‚è³¼äººè¢«æ–°å¢çš„åœ˜æ‹†
  let groupBreaks = await supabase.queryAll('breaks', { eq: { user_id: userId }, order: { column: 'created_at', ascending: false } });
  
  // æŸ¥è©¢å‡ºè²¨ç´€éŒ„ï¼ˆä½¿ç”¨ shipments è³‡æ–™è¡¨ï¼‰
  let shipments = await supabase.query('shipments', { eq: { user_id: userId }, order: { column: 'shipment_date', ascending: false } });
  
  console.log('[ORDER_INFO] Orders: ' + (Array.isArray(orders) ? orders.length : 'non-array') + ' items');
  console.log('[ORDER_INFO] Group breaks: ' + (Array.isArray(groupBreaks) ? groupBreaks.length : 'non-array') + ' items');
  console.log('[ORDER_INFO] Shipments: ' + (Array.isArray(shipments) ? shipments.length : 'non-array') + ' items');
  
  if (Array.isArray(orders) && orders.length > 0) {
    console.log('[ORDER_INFO] Sample order:', JSON.stringify(orders[0]));
  }
  
  // ğŸŒŸ å‹•æ…‹è¨ˆç®—å…¨ç«™ç´¯ç©å¼µæ•¸ï¼ˆç”¨æ–¼è¨‚å–®åˆ—è¡¨é¡¯ç¤ºï¼‰
  const accumulatedMap = new Map();
  const accumulatedItemMap = new Map();
  try {
    // ğŸ”‘ ä½¿ç”¨ queryAll æŸ¥è©¢æ‰€æœ‰è¨‚å–®ï¼ˆç„¡é™åˆ¶ï¼‰
    const { rows: allOrders } = await fetchAllOrdersForAccumulation(supabase);
    
    console.log('[ORDER_INFO] æŸ¥è©¢åˆ° ' + (Array.isArray(allOrders) ? allOrders.length : 0) + ' ç­†è¨‚å–®ç”¨æ–¼è¨ˆç®—ç´¯ç©');
    
    if (Array.isArray(allOrders)) {
      allOrders.forEach(order => {
        const orderItem = order.item || order.item_name || order.product_name || '';
        const orderCard = order.card_no || order.cardno || '';
        const key = buildKey(orderItem, orderCard);
        const itemKey = buildItemKey(orderItem);
        const qty = parseInt(order.quantity) || 0;
        if (qty > 0 && itemKey) {
          accumulatedMap.set(key, (accumulatedMap.get(key) || 0) + qty);
          accumulatedItemMap.set(itemKey, (accumulatedItemMap.get(itemKey) || 0) + qty);
        }
      });
      console.log('[ORDER_INFO] ç´¯ç©å¼µæ•¸è¨ˆç®—å®Œæˆï¼Œå…± ' + accumulatedMap.size + ' å€‹å•†å“æœ‰è¨‚å–®');
    }
  } catch (error) {
    console.error('[ORDER_INFO] è¨ˆç®—ç´¯ç©å¼µæ•¸å¤±æ•—:', error);
  }
  
  const formattedOrders = Array.isArray(orders) ? orders.map(o => {
    // ä½¿ç”¨æ¨™æº–åŒ–çš„ keyï¼ˆè½‰å°å¯«ï¼‰
    const key = buildKey(o.item, o.card_no);
    const itemKey = buildItemKey(o.item);
    const accumulatedCount = (accumulatedMap.get(key) != null)
      ? accumulatedMap.get(key)
      : (accumulatedItemMap.get(itemKey) || 0);
    // box_order æ¬„ä½ï¼štrue/false å­—ä¸²
    let boxOrderValue = 'false';
    if (typeof o.box_order !== 'undefined' && o.box_order !== null) {
      if (o.box_order === true || o.box_order === 'true' || o.box_order === 1 || o.box_order === '1') {
        boxOrderValue = 'true';
      }
    }
    return {
      id: o.id, // ğŸ”‘ åŠ å…¥è¨‚å–® IDï¼Œç”¨æ–¼ä»˜æ¬¾é€šçŸ¥
      item: o.item,
      cardNo: o.card_no,
      quantity: o.quantity,
      price: o.unit_price || 0,
      total: o.total_fee || 0,
      totalFee: o.total_fee || 0,
      balance: o.balance_amount || 0,
      balanceAmount: o.balance_amount || 0,
      deposit: o.deposit || 0,
      isCleared: o.is_cleared ? 'Y' : 'N',
      status: o.status || 'å¾…ç¢ºèª',
      arrivalStatus: o.arrival_status || '',
      isShipped: o.is_shipped || false,
      imageUrl: o.image_url || '',
      timestamp: o.timestamp,
      date: o.timestamp,
      box_order: boxOrderValue,
      isBox: 'N', // å¾ orders è³‡æ–™è¡¨ä¾†çš„éƒ½æ˜¯å–®å¡
      ç´¯ç©å¼µæ•¸: accumulatedCount // ğŸŒŸ é¡¯ç¤ºå…¨ç«™ç´¯ç©å¼µæ•¸
    };
  }) : [];
  
  const formattedBreaks = Array.isArray(groupBreaks) ? groupBreaks.map(b => {
    // ğŸ”¥ ç§»é™¤ category ä¸­çš„æ‰€æœ‰ emoji å’Œç‰¹æ®Šå­—ç¬¦ï¼Œåªä¿ç•™ä¸­æ–‡æ–‡å­—
    let cleanCategory = (b.category || 'æ£’çƒ')
      .replace(/[\u{1F300}-\u{1F9FF}]/gu, '') // ç§»é™¤ emoji (Unicode ç¯„åœ)
      .replace(/[âš¾ğŸ€ğŸ¯]/g, '') // ç§»é™¤ç‰¹å®š emoji
      .replace(/[^\p{L}\p{N}]/gu, '') // åªä¿ç•™å­—æ¯å’Œæ•¸å­—
      .trim() || 'æ£’çƒ';
    
    return {
      id: b.break_id,
      name: b.name,
      category: cleanCategory,
      format: b.format || 'éš¨æ©Ÿ',  // ğŸ”§ æ·»åŠ åœ˜æ‹†å½¢å¼
      item: b.item || '',          // ğŸ”§ æ·»åŠ è³¼è²·å“é …
      totalFee: b.total_fee || 0,
      paid: b.paid || 0,
      balance: b.balance || 0,
      status: b.status || '',
      isOpened: b.is_opened || false,
      isShipped: b.is_shipped || false,
      paymentNotified: b.payment_notified || false,
      timestamp: b.created_at
    };
  }) : [];
  
  console.log('[ORDER_INFO] ğŸ” åœ˜æ‹†åˆ†é¡ Debug:');
  if (Array.isArray(groupBreaks)) {
    groupBreaks.forEach((b, idx) => {
      let cleanCategory = (b.category || 'æ£’çƒ')
        .replace(/[\u{1F300}-\u{1F9FF}]/gu, '')
        .replace(/[âš¾ğŸ€ğŸ¯]/g, '')
        .replace(/[^\p{L}\p{N}]/gu, '')
        .trim() || 'æ£’çƒ';
      console.log('[ORDER_INFO]   [' + idx + '] break_id=' + b.break_id + ', raw_category=' + (b.category || 'NULL') + ', clean_category=' + cleanCategory);
    });
  }
  
  const formattedShipments = Array.isArray(shipments) ? shipments.map(s => ({
    id: s.id,
    shipmentNo: s.shipment_no,
    shipmentDate: s.shipment_date,
    trackingNo: s.tracking_no,
    items: s.items,
    status: s.status || '',
    nickname: s.nickname,
    realName: s.real_name,
    phone: s.phone,
    shipStore: s.ship_store,
    storeNumber: s.store_number,
    remark: s.remark,
    createdAt: s.created_at
  })) : [];
  
  console.log('[ORDER_INFO] Returning ' + formattedOrders.length + ' orders, ' + formattedBreaks.length + ' breaks, ' + formattedShipments.length + ' shipments');
  
  // è¿”å›ç”¨æˆ¶è³‡è¨Šä»¥åŠè¨‚å–®å’Œåœ˜æ‹†è¨˜éŒ„
  return { 
    success: true,
    id: users[0].id,  // ğŸ”¥ æ·»åŠ  user_idï¼Œå‰ç«¯æ”¯ä»˜æ™‚æœƒç”¨åˆ°
    nickname: users[0].nickname,
    phone: users[0].phone,
    email: users[0].email,
    address: users[0].address,
    customerName: users[0].real_name,
    cvs_store_name: users[0].cvs_store_name,
    cvs_store_id: users[0].cvs_store_id,
    orders: formattedOrders, 
    groupBreaks: formattedBreaks,
    shipments: formattedShipments
  };
}

async function handleAddOrder(body, supabase) {
  console.log('[ADD_ORDER] ===== é–‹å§‹è™•ç†è¨‚å–® =====');
  console.log('[ADD_ORDER] æ”¶åˆ°çš„ body:', JSON.stringify(body));
  console.log('[ADD_ORDER] body çš„ keys:', Object.keys(body));
  
  // ğŸ”§ åŒæ™‚æ”¯æ´ orderEntries å’Œ entries å…©ç¨®æ ¼å¼
  const { nickname, phone, orderEntries, entries } = body;
  const rawEntries = orderEntries || entries;
  
  console.log('[ADD_ORDER] nickname:', nickname);
  console.log('[ADD_ORDER] phone:', phone);
  console.log('[ADD_ORDER] orderEntries:', orderEntries);
  console.log('[ADD_ORDER] entries:', entries);
  console.log('[ADD_ORDER] rawEntries:', rawEntries);
  console.log('[ADD_ORDER] rawEntries é¡å‹:', typeof rawEntries);
  console.log('[ADD_ORDER] rawEntries æ˜¯å¦ç‚ºé™£åˆ—:', Array.isArray(rawEntries));
  console.log('[ADD_ORDER] rawEntries é•·åº¦:', rawEntries ? rawEntries.length : 'undefined');
  
  if (!rawEntries) {
    console.error('[ADD_ORDER] âŒ è¨‚å–®è³‡æ–™ç‚ºç©º');
    return { success: false, message: 'è¨‚å–®è³‡æ–™ç‚ºç©º (orderEntries/entries ä¸å­˜åœ¨)' };
  }
  
  if (!Array.isArray(rawEntries)) {
    console.error('[ADD_ORDER] âŒ è¨‚å–®è³‡æ–™ä¸æ˜¯é™£åˆ—ï¼Œé¡å‹:', typeof rawEntries);
    return { success: false, message: 'è¨‚å–®è³‡æ–™æ ¼å¼éŒ¯èª¤ (ä¸æ˜¯é™£åˆ—)' };
  }
  
  if (rawEntries.length === 0) {
    console.error('[ADD_ORDER] âŒ è¨‚å–®è³‡æ–™é•·åº¦ç‚º 0');
    return { success: false, message: 'è¨‚å–®è³‡æ–™ç‚ºç©º (é™£åˆ—é•·åº¦ç‚º 0)' };
  }
  
  // ğŸ”§ æ¨™æº–åŒ–è¨‚å–®è³‡æ–™æ ¼å¼ï¼ˆæ”¯æ´å…©ç¨®æ ¼å¼ï¼‰
  // æ ¼å¼ 1: { item, cardNo, quantity, unitPrice }
  // æ ¼å¼ 2: { item, cardNo, qty, price }
  const normalizedEntries = rawEntries.map(entry => ({
    item: entry.item,
    cardNo: entry.cardNo,
    quantity: entry.quantity || entry.qty || 1,
    unitPrice: entry.unitPrice || entry.price || 0
  }));
  
  console.log('[ADD_ORDER] æ¨™æº–åŒ–å¾Œçš„è¨‚å–®:', normalizedEntries);
  console.log('[ADD_ORDER] æ¨™æº–åŒ–å¾Œçš„è¨‚å–®:', normalizedEntries);
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  const now = getTaiwanTimeISO(); // ğŸ”§ ä½¿ç”¨å°ç£æ™‚é–“
  
  // ğŸŒŸ æŸ¥è©¢æ‰€æœ‰å•†å“ç›®éŒ„ä»¥ç²å–åœ–ç‰‡ã€åˆ°è²¨ç‹€æ…‹ã€é–€æª»åƒ¹ç­‰è³‡è¨Š
  const products = await supabase.query('product_catalog', {});
  const productMap = new Map();
  
  console.log('[ADD_ORDER] æŸ¥è©¢åˆ° ' + (Array.isArray(products) ? products.length : 0) + ' å€‹å•†å“');
  
  if (Array.isArray(products)) {
    products.forEach((p, idx) => {
      // æ¨™æº–åŒ– key
      const key = buildKey(p.item_name, p.card_no);
      
      // ğŸ”‘ é™¤éŒ¯ï¼šé¡¯ç¤ºå‰ 3 å€‹å•†å“çš„åŸå§‹è³‡æ–™
      if (idx < 3) {
        console.log('[ADD_ORDER] å•†å“ #' + idx + ' åŸå§‹è³‡æ–™:', {
          item_name: p.item_name,
          card_no: p.card_no,
          price: p.price,
          threshold_price: p.threshold_price,
          discount_threshold: p.discount_threshold,
          key: key
        });
      }
      
      // ğŸ”‘ é–€æª»åƒ¹æ ¼ï¼šå„ªå…ˆä½¿ç”¨ threshold_priceï¼Œè‹¥ç‚º 0 å‰‡ä½¿ç”¨ price
      const thresholdPrice = parseFloat(p.threshold_price) || parseFloat(p.price) || 0;
      const regularPrice = parseFloat(p.price) || 0;
      
      productMap.set(key, {
        imageUrl: p.image_url_1 || '',
        arrivalStatus: p.stock_status || '',
        threshold: parseInt(p.discount_threshold) || 0,
        fullPrice: thresholdPrice, // é–€æª»åƒ¹æ ¼
        regularPrice: regularPrice, // åŸåƒ¹
        isOpen: p.is_available !== 'N', // ğŸ”‘ åªæœ‰æ˜ç¢ºè¨­ç‚º 'N' æ‰è¦–ç‚ºé—œé–‰
        isAvailableValue: p.is_available, // è¨˜éŒ„åŸå§‹å€¼ç”¨æ–¼é™¤éŒ¯
        stock: parseInt(p.remaining_stock) || 0,
        isBoxPreorder: parseBoolValue(p.is_box_preorder), // ğŸ”‘ å¡ç›’åˆ¤æ–·æ¬„ä½
        // è¨˜éŒ„åŸå§‹è³‡æ–™ç”¨æ–¼é™¤éŒ¯
        rawThresholdPrice: p.threshold_price,
        rawPrice: p.price,
        rawDiscountThreshold: p.discount_threshold
      });
    });
  }
  
  // ğŸŒŸ å‹•æ…‹è¨ˆç®—ç•¶å‰å…¨ç«™ç´¯ç©å¼µæ•¸ï¼ˆå¾ç¾æœ‰è¨‚å–®åŠ ç¸½ï¼‰
  const accumulatedMap = new Map();
  const accumulatedItemMap = new Map();
  try {
    // ğŸ”‘ ä½¿ç”¨ queryAll æŸ¥è©¢æ‰€æœ‰è¨‚å–®ï¼ˆç„¡é™åˆ¶ï¼‰
    const { rows: allOrders } = await fetchAllOrdersForAccumulation(supabase);
    
    console.log('[ADD_ORDER] æŸ¥è©¢åˆ° ' + (Array.isArray(allOrders) ? allOrders.length : 0) + ' ç­†è¨‚å–®ç”¨æ–¼è¨ˆç®—ç´¯ç©');
    
    if (Array.isArray(allOrders)) {
      allOrders.forEach(order => {
        const orderItem = order.item || order.item_name || order.product_name || '';
        const orderCard = order.card_no || order.cardno || '';
        const key = buildKey(orderItem, orderCard);
        const itemKey = buildItemKey(orderItem);
        const qty = parseInt(order.quantity) || 0;
        if (qty > 0 && itemKey) {
          accumulatedMap.set(key, (accumulatedMap.get(key) || 0) + qty);
          accumulatedItemMap.set(itemKey, (accumulatedItemMap.get(itemKey) || 0) + qty);
        }
      });
      console.log('[ADD_ORDER] ç´¯ç©å¼µæ•¸è¨ˆç®—å®Œæˆï¼Œå…± ' + accumulatedMap.size + ' å€‹å•†å“æœ‰è¨‚å–®');
    }
  } catch (error) {
    console.error('[ADD_ORDER] è¨ˆç®—ç´¯ç©å¼µæ•¸å¤±æ•—:', error);
  }
  
  console.log('[ADD_ORDER] é–‹å§‹è½‰æ›è¨‚å–®é …ç›®ï¼Œå…±', normalizedEntries.length, 'ç­†');
  
  const ordersToInsert = normalizedEntries.map((entry, index) => {
    console.log('[ADD_ORDER] è™•ç†ç¬¬', index + 1, 'ç­†è¨‚å–®ï¼ŒåŸå§‹è³‡æ–™:', entry);
    
    const itemName = String(entry.item || '').trim();
    const cardNo = String(entry.cardNo || '').trim();
    const key = buildKey(itemName, cardNo);
    const quantity = parseInt(entry.quantity) || 1;
    let unitPrice = parseFloat(entry.unitPrice) || 0;
    
    console.log('[ADD_ORDER] è™•ç†è¨‚å–®é …ç›® #' + (index + 1) + ':', { itemName, cardNo, key, quantity, unitPrice });
    
    // ğŸŒŸ å¾å•†å“ç›®éŒ„ç²å–è³‡è¨Š
    const productInfo = productMap.get(key);
    let imageUrl = '';
    let arrivalStatus = '';
    
    console.log('[ADD_ORDER] æŸ¥è©¢å•†å“è³‡è¨Šï¼Œkey:', key);
    console.log('[ADD_ORDER] productMap ä¸­æ˜¯å¦å­˜åœ¨:', productMap.has(key));
    
    if (!productInfo) {
      // æ‰¾ä¸åˆ°å•†å“è³‡è¨Šï¼Œåˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„ key
      console.error('[ADD_ORDER] âŒ æ‰¾ä¸åˆ°å•†å“è³‡è¨Šï¼æŸ¥è©¢ key:', key);
      console.error('[ADD_ORDER] å•†å“ç›®éŒ„ä¸­çš„ keys (å‰10å€‹):', Array.from(productMap.keys()).slice(0, 10));
      
      // å˜—è©¦æ‰¾ç›¸ä¼¼çš„ key
      const similarKeys = Array.from(productMap.keys()).filter(k => k.includes(itemName.toLowerCase()));
      console.error('[ADD_ORDER] ç›¸ä¼¼çš„ keys:', similarKeys);
      
      throw new Error('æ‰¾ä¸åˆ°å•†å“ã€' + itemName + 'ã€‘çš„è³‡è¨Šï¼Œè«‹é‡æ–°æ•´ç†é é¢');
    }
    
    imageUrl = productInfo.imageUrl;
    arrivalStatus = productInfo.arrivalStatus;
    
    console.log('[ADD_ORDER] å•†å“è³‡è¨Š:', { 
      isOpen: productInfo.isOpen, 
      isAvailableValue: productInfo.isAvailableValue,
      threshold: productInfo.threshold, 
      fullPrice: productInfo.fullPrice,
      regularPrice: productInfo.regularPrice,
      rawThresholdPrice: productInfo.rawThresholdPrice,
      rawPrice: productInfo.rawPrice
    });
    
    // ğŸŒŸ æª¢æŸ¥æ˜¯å¦é–‹æ”¾ï¼ˆåªæœ‰æ˜ç¢ºè¨­ç‚º 'N' æ‰æ‹’çµ•ï¼‰
    if (productInfo.isAvailableValue === 'N') {
      console.error('[ADD_ORDER] âŒ å•†å“å·²é—œé–‰:', itemName, '(is_available = N)');
      throw new Error('ã€' + itemName + 'ã€‘å·²æˆªæ­¢ä¸‹å–®ï¼è«‹é‡æ–°æ•´ç†é é¢æŸ¥çœ‹æœ€æ–°å•†å“');
    }
    // ğŸŒŸ æª¢æŸ¥æ˜¯å¦é–‹æ”¾ï¼ˆå…è¨±æœªè¨­å®šçš„æƒ…æ³ï¼Œé è¨­ç‚ºé–‹æ”¾ï¼‰
    if (productInfo.isOpen === false) {
      console.error('[ADD_ORDER] âŒ å•†å“å·²é—œé–‰:', itemName);
      throw new Error('ã€' + itemName + 'ã€‘å·²æˆªæ­¢ä¸‹å–®ï¼è«‹é‡æ–°æ•´ç†é é¢æŸ¥çœ‹æœ€æ–°å•†å“');
    }
    
    // ğŸŒŸ æ ¹æ“šå…¨ç«™ç´¯ç©å¼µæ•¸è‡ªå‹•èª¿æ•´åƒ¹æ ¼ï¼ˆé”åˆ°é–€æª»ç”¨é–€æª»åƒ¹ï¼‰
    if (productInfo.threshold > 0 && productInfo.fullPrice > 0) {
      const itemKey = buildItemKey(itemName);
      const currentAccumulated = (accumulatedMap.get(key) != null)
        ? accumulatedMap.get(key)
        : (accumulatedItemMap.get(itemKey) || 0); // ğŸ”‘ å¾å‹•æ…‹è¨ˆç®—çš„ç´¯ç©è®€å–
      // ğŸ”‘ åŠ ä¸Šæœ¬æ¬¡è¨‚å–®çš„æ•¸é‡ä¾†è¨ˆç®—ç¸½ç´¯ç©
      const totalAfterOrder = currentAccumulated + quantity;
      
      if (totalAfterOrder >= productInfo.threshold) {
        unitPrice = productInfo.fullPrice;
        console.log('[ADD_ORDER] ' + itemName + ' ç´¯ç© ' + totalAfterOrder + ' å¼µ >= é–€æª» ' + productInfo.threshold + 'ï¼Œä½¿ç”¨é–€æª»åƒ¹ ' + unitPrice);
      } else {
        console.log('[ADD_ORDER] ' + itemName + ' ç´¯ç© ' + totalAfterOrder + ' å¼µ < é–€æª» ' + productInfo.threshold + 'ï¼Œä½¿ç”¨åŸåƒ¹ ' + unitPrice);
      }
    }
    
    const totalFee = unitPrice * quantity;
    
    // åˆ¤æ–·æ˜¯å¦ç‚ºå¡ç›’å•†å“ï¼ˆåªæ¥å— true æ‰ç®—å¡ç›’ï¼Œå…¶é¤˜çš†ç‚º falseï¼‰
    let boxOrderValue = false;
    if (productInfo && (productInfo.isBoxPreorder === true || productInfo.isBoxPreorder === 'true' || productInfo.isBoxPreorder === 1 || productInfo.isBoxPreorder === '1')) {
      boxOrderValue = true;
    }
    return {
      user_id: userId,
      timestamp: now,
      item: itemName,
      card_no: cardNo,
      quantity: quantity,
      unit_price: unitPrice,
      total_fee: totalFee,
      balance_amount: totalFee,
      deposit: 0,
      is_cleared: false,
      status: 'å¾…ç¢ºèª',
      arrival_status: arrivalStatus,
      image_url: imageUrl,
      box_order: boxOrderValue
    };
  });
  
  console.log('[ADD_ORDER] æº–å‚™æ’å…¥è¨‚å–®ï¼Œå…±', ordersToInsert.length, 'ç­†');
  console.log('[ADD_ORDER] æ’å…¥è³‡æ–™:', JSON.stringify(ordersToInsert, null, 2));
  
  const result = await supabase.insert('orders', ordersToInsert);
  
  console.log('[ADD_ORDER] æ’å…¥çµæœ:', result);
  console.log('[ADD_ORDER] æ’å…¥æˆåŠŸç­†æ•¸:', result ? result.length : 0);
  
  // ğŸŒŸ æ‰£æ¸›å•†å“åº«å­˜ï¼ˆåªé‡å°å¡ç›’å•†å“ï¼‰
  try {
    console.log('[ADD_ORDER] é–‹å§‹æª¢æŸ¥æ˜¯å¦éœ€è¦æ‰£æ¸›åº«å­˜...');
    
    for (const entry of normalizedEntries) {
      const itemName = String(entry.item || '').trim();
      const cardNo = String(entry.cardNo || '').trim();
      const quantity = parseInt(entry.quantity) || 1;
      const key = buildKey(itemName, cardNo);
      
      const productInfo = productMap.get(key);
      if (!productInfo) {
        console.warn('[ADD_ORDER] âš ï¸ æ‰¾ä¸åˆ°å•†å“è³‡è¨Šï¼Œç„¡æ³•æ‰£æ¸›åº«å­˜:', itemName, cardNo);
        continue;
      }
      
      // ğŸ”‘ æª¢æŸ¥æ˜¯å¦ç‚ºå¡ç›’å•†å“ï¼ˆåªæœ‰å¡ç›’æ‰æ‰£æ¸›åº«å­˜ï¼‰
      const products = await supabase.query('product_catalog', { 
        eq: { item_name: itemName, card_no: cardNo } 
      });
      
      if (Array.isArray(products) && products.length > 0) {
        const isBoxProduct = parseBoolValue(products[0].is_box_preorder);
        
        if (!isBoxProduct) {
          console.log('[ADD_ORDER] â­ï¸ è·³éåº«å­˜æ‰£æ¸›:', itemName, '(éå¡ç›’å•†å“)');
          continue;
        }
      }
      
      const currentStock = productInfo.stock || 0;
      const newStock = Math.max(0, currentStock - quantity);
      
      console.log('[ADD_ORDER] æ‰£æ¸›åº«å­˜ (å¡ç›’):', itemName, 'åŸåº«å­˜:', currentStock, 'ä¸‹å–®:', quantity, 'æ–°åº«å­˜:', newStock);
      
      // æ›´æ–° product_catalog çš„ remaining_stock
      const updateStockUrl = `${supabase.url}/rest/v1/product_catalog?item_name=eq.${encodeURIComponent(itemName)}&card_no=eq.${encodeURIComponent(cardNo)}`;
      await fetch(updateStockUrl, {
        method: 'PATCH',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        },
        body: JSON.stringify({
          remaining_stock: newStock
        })
      });
      
      console.log('[ADD_ORDER] âœ… å·²æ›´æ–°å•†å“åº«å­˜:', itemName, 'â†’', newStock);
    }
  } catch (error) {
    console.error('[ADD_ORDER] æ‰£æ¸›åº«å­˜å¤±æ•—:', error);
    // ä¸å½±éŸ¿è¨‚å–®æ–°å¢ï¼Œåªè¨˜éŒ„éŒ¯èª¤
  }
  
  console.log('[ADD_ORDER] ğŸ” é–‹å§‹æª¢æŸ¥é–€æª»åƒ¹æ ¼æ›´æ–°é‚è¼¯...');
  
  // ğŸŒŸ æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°èˆŠè¨‚å–®åƒ¹æ ¼ï¼ˆé”åˆ°é–€æª»æ™‚ï¼‰
  // é€™æ˜¯åŸå§‹ backend.js çš„é‚è¼¯ï¼šé”åˆ°é–€æª»å¾Œï¼Œæ›´æ–°æ‰€æœ‰ç”¨æˆ¶è©²å•†å“çš„è¨‚å–®åƒ¹æ ¼
  try {
    for (const entry of normalizedEntries) {
      const itemName = String(entry.item || '').trim();
      const cardNo = String(entry.cardNo || '').trim();
      const key = buildKey(itemName, cardNo); // ğŸ”‘ ä½¿ç”¨æ¨™æº–åŒ– key
      const quantity = parseInt(entry.quantity) || 1;
      
      console.log('[ADD_ORDER] æª¢æŸ¥å•†å“:', itemName, 'key:', key);
      
      const productInfo = productMap.get(key);
      if (!productInfo || !productInfo.threshold || !productInfo.fullPrice) {
        console.log('[ADD_ORDER] â­ï¸ è·³éåƒ¹æ ¼æ›´æ–°æª¢æŸ¥:', itemName, '(ç„¡é–€æª»è¨­å®š)');
        console.log('[ADD_ORDER]   - threshold:', productInfo?.threshold || 0);
        console.log('[ADD_ORDER]   - fullPrice:', productInfo?.fullPrice || 0);
        console.log('[ADD_ORDER]   - regularPrice:', productInfo?.regularPrice || 0);
        console.log('[ADD_ORDER]   - rawThresholdPrice:', productInfo?.rawThresholdPrice);
        console.log('[ADD_ORDER]   - rawPrice:', productInfo?.rawPrice);
        
        // ğŸ”‘ å¦‚æœæœ‰é–€æª»æ•¸é‡ä½†æ²’æœ‰é–€æª»åƒ¹æ ¼ï¼Œä½¿ç”¨åŸåƒ¹ä½œç‚ºé–€æª»åƒ¹æ ¼
        if (productInfo && productInfo.threshold > 0 && productInfo.regularPrice > 0) {
          console.log('[ADD_ORDER] âš ï¸ å•†å“æœ‰é–€æª»æ•¸é‡ä½†ç„¡é–€æª»åƒ¹æ ¼ï¼Œä½¿ç”¨åŸåƒ¹', productInfo.regularPrice, 'ä½œç‚ºé–€æª»åƒ¹æ ¼');
          productInfo.fullPrice = productInfo.regularPrice;
        } else {
          continue;
        }
      }
      
      console.log('[ADD_ORDER] ğŸ“Š å•†å“', itemName, 'æœ‰é–€æª»è¨­å®š: threshold=' + productInfo.threshold + ', fullPrice=' + productInfo.fullPrice);
      
      // é‡æ–°è¨ˆç®—ç´¯ç©å¼µæ•¸ï¼ˆåŒ…å«å‰›æ–°å¢çš„è¨‚å–®ï¼‰
      const ordersUrl = `${supabase.url}/rest/v1/orders?item=eq.${encodeURIComponent(itemName)}&card_no=eq.${encodeURIComponent(cardNo)}&select=quantity`;
      const ordersResp = await fetch(ordersUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      const allProductOrders = await ordersResp.json();
      
      let totalAccumulated = 0;
      if (Array.isArray(allProductOrders)) {
        allProductOrders.forEach(o => {
          totalAccumulated += parseInt(o.quantity) || 0;
        });
      }
      
      console.log('[ADD_ORDER] ' + itemName + ' æœ€æ–°ç´¯ç©: ' + totalAccumulated + ', é–€æª»: ' + productInfo.threshold);
      
      // ğŸ¯ å¦‚æœé”åˆ°é–€æª»ï¼Œæ›´æ–°ã€Œæ‰€æœ‰ç”¨æˆ¶ã€è©²å•†å“çš„è¨‚å–®åƒ¹æ ¼ï¼ˆä¸é™è©²ç”¨æˆ¶ï¼‰
      if (totalAccumulated >= productInfo.threshold) {
        console.log('[ADD_ORDER] ğŸ¯ é”åˆ°é–€æª»ï¼é–‹å§‹æ›´æ–°æ‰€æœ‰ç”¨æˆ¶çš„ ' + itemName + ' è¨‚å–®åƒ¹æ ¼ -> ' + productInfo.fullPrice);
        
        // ğŸ”‘ æŸ¥è©¢ã€Œæ‰€æœ‰ç”¨æˆ¶ã€è©²å•†å“çš„è¨‚å–®ï¼ˆç§»é™¤ user_id é™åˆ¶ï¼‰
        const allOrdersUrl = `${supabase.url}/rest/v1/orders?item=eq.${encodeURIComponent(itemName)}&card_no=eq.${encodeURIComponent(cardNo)}&select=id,quantity,unit_price,deposit,user_id,remark`;
        console.log('[ADD_ORDER] æŸ¥è©¢æ‰€æœ‰è¨‚å–® URL:', allOrdersUrl);
        
        const allOrdersResp = await fetch(allOrdersUrl, {
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`
          }
        });
        const allOrders = await allOrdersResp.json();
        
        console.log('[ADD_ORDER] æŸ¥è©¢åˆ° ' + (Array.isArray(allOrders) ? allOrders.length : 0) + ' ç­†è¨‚å–®');
        
        if (Array.isArray(allOrders)) {
          let updatedCount = 0;
          let skippedCount = 0;
          let manualPriceCount = 0;
          
          for (const order of allOrders) {
            // ğŸ”’ è·³éæ‰‹å‹•èª¿åƒ¹çš„è¨‚å–®
            if (order.remark === true || order.remark === 'true') {
              manualPriceCount++;
              console.log('[ADD_ORDER] ğŸ”’ è·³éè¨‚å–® ' + order.id + ' (æ‰‹å‹•èª¿åƒ¹é–å®š)');
              continue;
            }
            
            const priceDiff = Math.abs(order.unit_price - productInfo.fullPrice);
            console.log('[ADD_ORDER] è¨‚å–® ' + order.id + ' (user_id=' + order.user_id + '): ç›®å‰åƒ¹æ ¼=' + order.unit_price + ', é–€æª»åƒ¹=' + productInfo.fullPrice + ', å·®ç•°=' + priceDiff);
            
            // åªæ›´æ–°åƒ¹æ ¼ä¸æ˜¯é–€æª»åƒ¹çš„è¨‚å–®
            if (priceDiff > 0.01) {
              const newTotal = order.quantity * productInfo.fullPrice;
              const newBalance = newTotal - (order.deposit || 0);
              
              const patchUrl = `${supabase.url}/rest/v1/orders?id=eq.${order.id}`;
              const patchResp = await fetch(patchUrl, {
                method: 'PATCH',
                headers: {
                  'apikey': supabase.apiKey,
                  'Authorization': `Bearer ${supabase.apiKey}`,
                  'Content-Type': 'application/json',
                  'Prefer': 'return=minimal'
                },
                body: JSON.stringify({
                  unit_price: productInfo.fullPrice,
                  total_fee: newTotal,
                  balance_amount: newBalance
                })
              });
              
              console.log('[ADD_ORDER] PATCH å›æ‡‰ç‹€æ…‹:', patchResp.status, patchResp.statusText);
              
              updatedCount++;
              console.log('[ADD_ORDER] âœ… å·²æ›´æ–°è¨‚å–® ' + order.id + ' åƒ¹æ ¼: ' + order.unit_price + ' -> ' + productInfo.fullPrice);
            } else {
              skippedCount++;
              console.log('[ADD_ORDER] â­ï¸ è·³éè¨‚å–® ' + order.id + ' (åƒ¹æ ¼å·²æ˜¯é–€æª»åƒ¹)');
            }
          }
          console.log('[ADD_ORDER] ğŸ‰ æ›´æ–°çµæœ: å·²æ›´æ–° ' + updatedCount + ' ç­†ï¼Œè·³é ' + skippedCount + ' ç­†ï¼ˆåƒ¹æ ¼å·²æ­£ç¢ºï¼‰ï¼Œæ‰‹å‹•èª¿åƒ¹é–å®š ' + manualPriceCount + ' ç­†');
        }
      } else {
        console.log('[ADD_ORDER] â­ï¸ æœªé”é–€æª»ï¼Œä¸æ›´æ–°èˆŠè¨‚å–® (ç´¯ç© ' + totalAccumulated + ' < é–€æª» ' + productInfo.threshold + ')');
      }
    }
  } catch (error) {
    console.error('[ADD_ORDER] æ›´æ–°èˆŠè¨‚å–®åƒ¹æ ¼å¤±æ•—:', error);
    // ä¸å½±éŸ¿è¨‚å–®æ–°å¢ï¼Œåªè¨˜éŒ„éŒ¯èª¤
  }
  
  console.log('[ADD_ORDER] âœ… è¨‚å–®æ–°å¢å®Œæˆï¼Œå…± ' + normalizedEntries.length + ' ç­†');
  
  // ğŸŒŸ å¯„é€ email é€šçŸ¥å•†å®¶
  try {
    await sendOrderNotificationEmail(nickname, phone, ordersToInsert);
    console.log('[ADD_ORDER] âœ… Email é€šçŸ¥å·²ç™¼é€');
  } catch (emailError) {
    console.error('[ADD_ORDER] âŒ Email é€šçŸ¥ç™¼é€å¤±æ•—:', emailError);
    // ä¸å½±éŸ¿è¨‚å–®æ–°å¢ï¼Œåªè¨˜éŒ„éŒ¯èª¤
  }
  
  return { success: true, message: 'è¨‚å–®æ–°å¢æˆåŠŸ', insertedCount: result ? result.length : 0 };
}

async function sendOrderNotificationEmail(nickname, phone, orders) {
  const resendApiKey = 're_9eMazG8M_NZZGeeT4DTWXMCAs3UGyBQWS'; // ğŸ”‘ ä½ çš„ Resend API key
  const merchantEmail = 'ningscard@gmail.com'; // ğŸ”‘ è«‹æ”¹æˆä½ çš„ Gmail
  
  // çµ„è£è¨‚å–®æ˜ç´°
  let orderDetails = '';
  let totalAmount = 0;
  orders.forEach((o, idx) => {
    orderDetails += `${idx + 1}. ${o.item} ${o.card_no ? '(' + o.card_no + ')' : ''}\n`;
    orderDetails += `   æ•¸é‡: ${o.quantity} | å–®åƒ¹: NT$ ${o.unit_price} | å°è¨ˆ: NT$ ${o.total_fee}\n\n`;
    totalAmount += o.total_fee;
  });
  
  const emailBody = `
æ–°è¨‚å–®é€šçŸ¥

å®¢æˆ¶è³‡è¨Šï¼š
- æš±ç¨±ï¼š${nickname}
- é›»è©±ï¼š${phone}

è¨‚å–®æ˜ç´°ï¼š
${orderDetails}
ç¸½é‡‘é¡ï¼šNT$ ${totalAmount.toLocaleString()}

è«‹ç›¡å¿«è™•ç†æ­¤è¨‚å–®ã€‚
  `.trim();
  
  const response = await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${resendApiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      from: 'Ning Card Store <onboarding@resend.dev>', // Resend é è¨­å¯„ä»¶è€…
      to: [merchantEmail],
      subject: `ğŸ›’ æ–°è¨‚å–®é€šçŸ¥ - ${nickname} (${phone})`,
      text: emailBody
    })
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error('Resend API éŒ¯èª¤: ' + error);
  }
  
  return await response.json();
}

/**
 * å¯„é€ä»˜æ¬¾é€šçŸ¥ Email çµ¦å•†å®¶
 */
async function sendPaymentNotificationEmail(nickname, phone, paymentItems) {
  const resendApiKey = 're_9eMazG8M_NZZGeeT4DTWXMCAs3UGyBQWS';
  const merchantEmail = 'ningscard@gmail.com';
  
  // çµ„è£ä»˜æ¬¾é …ç›®æ˜ç´°
  let paymentDetails = '';
  let totalAmount = 0;
  paymentItems.forEach((item, idx) => {
    paymentDetails += `${idx + 1}. ${item.item || item.name}\n`;
    paymentDetails += `   ä»˜æ¬¾é‡‘é¡: NT$ ${item.amount}\n`;
    if (item.accountLast5) {
      paymentDetails += `   å¸³è™Ÿå¾Œäº”ç¢¼: ${item.accountLast5}\n`;
    }
    if (item.date) {
      paymentDetails += `   ä»˜æ¬¾æ—¥æœŸ: ${item.date}\n`;
    }
    if (item.note) {
      paymentDetails += `   å‚™è¨»: ${item.note}\n`;
    }
    paymentDetails += `\n`;
    totalAmount += parseFloat(item.amount) || 0;
  });
  
  const emailBody = `
ä»˜æ¬¾é€šçŸ¥

å®¢æˆ¶è³‡è¨Šï¼š
- æš±ç¨±ï¼š${nickname}
- é›»è©±ï¼š${phone}

ä»˜æ¬¾æ˜ç´°ï¼š
${paymentDetails}
ç¸½é‡‘é¡ï¼šNT$ ${totalAmount.toLocaleString()}

è«‹ç™»å…¥å¾Œå°ç¢ºèªæ­¤ç­†ä»˜æ¬¾ã€‚
  `.trim();
  
  const response = await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${resendApiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      from: 'Ning Card Store <onboarding@resend.dev>',
      to: [merchantEmail],
      subject: `ğŸ’° ä»˜æ¬¾é€šçŸ¥ - ${nickname} (${phone})`,
      text: emailBody
    })
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error('Resend API éŒ¯èª¤: ' + error);
  }
  
  return await response.json();
}

/**
 * å¯„é€å‡ºè²¨é€šçŸ¥ Email çµ¦å®¢æˆ¶
 */
async function sendShipmentNotificationEmail(userEmail, userName, shipmentNo, trackingNo, items, storeName) {
  const resendApiKey = 're_9eMazG8M_NZZGeeT4DTWXMCAs3UGyBQWS';
  
  const emailBody = `
è¦ªæ„›çš„ ${userName}ï¼Œæ‚¨å¥½ï¼

æ‚¨çš„è¨‚å–®å·²å®Œæˆå‡ºè²¨ï¼Œè©³ç´°è³‡è¨Šå¦‚ä¸‹ï¼š

å‡ºè²¨å–®è™Ÿï¼š${shipmentNo}
ç‰©æµå–®è™Ÿï¼š${trackingNo}
æ”¶ä»¶é–€å¸‚ï¼š${storeName || 'æœªæä¾›'}

å‡ºè²¨å•†å“ï¼š
${items}

æ‚¨å¯ä»¥é€éä»¥ä¸‹é€£çµæŸ¥è©¢ç‰©æµè³‡è¨Šï¼š
https://eservice.7-11.com.tw/e-tracking/search.aspx

æ„Ÿè¬æ‚¨çš„è³¼è²·ï¼

Ning's Card Store
  `.trim();
  
  const response = await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${resendApiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      from: 'Ning Card Store <onboarding@resend.dev>',
      to: [userEmail],
      subject: `ğŸšš å‡ºè²¨é€šçŸ¥ - è¨‚å–® ${shipmentNo}`,
      text: emailBody
    })
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error('Resend API éŒ¯èª¤: ' + error);
  }
  
  return await response.json();
}

async function handleGetPendingPaymentKeys(body, supabase) {
  const { nickname, phone } = body;
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  const pendingItems = [];
  
  // ç²å–æœªçµæ¸…çš„è¨‚å–®
  let orderQuery = `${supabase.url}/rest/v1/orders?user_id=eq.${userId}&is_cleared=eq.false&balance_amount=gt.0&select=*`;
  const ordersResp = await fetch(orderQuery, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const orders = await ordersResp.json();
  
  if (orders && Array.isArray(orders)) {
    orders.forEach(o => {
      pendingItems.push({
        type: 'order',
        key: `${o.item}_${o.card_no}`,
        item: o.item,
        cardNo: o.card_no,
        balance: o.balance_amount,
        timestamp: o.timestamp
      });
    });
  }
  
  // ç²å–æœªä»˜æ¸…çš„åœ˜æ‹†
  let breaksQuery = `${supabase.url}/rest/v1/breaks?user_id=eq.${userId}&balance=gt.0&select=*`;
  const breaksResp = await fetch(breaksQuery, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const breaks = await breaksResp.json();
  
  if (breaks && Array.isArray(breaks)) {
    breaks.forEach(b => {
      pendingItems.push({
        type: 'break',
        key: `${b.break_id}_${b.name}`,
        breakId: b.break_id,
        name: b.name,
        balance: b.balance,
        timestamp: b.created_at
      });
    });
  }
  
  return { success: true, pendingItems };
}

async function handleNotifyPaymentBulk(body, supabase) {
  const { nickname, phone, paymentItems } = body;
  
  if (!paymentItems || paymentItems.length === 0) {
    return { success: false, message: 'ä»˜æ¬¾é …ç›®ç‚ºç©º' };
  }
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  const now = getTaiwanTimeISO(); // ğŸ”§ ä½¿ç”¨å°ç£æ™‚é–“
  
  const historyRecords = paymentItems.map(item => ({
    user_id: userId,
    action: 'ä»˜æ¬¾é€šçŸ¥',
    details: `${item.item || item.name} - é‡‘é¡: ${item.amount}`,
    timestamp: now
  }));
  
  await supabase.insert('order_history', historyRecords);
  
  // ğŸ“§ å¯„é€ email é€šçŸ¥å•†å®¶
  try {
    await sendPaymentNotificationEmail(nickname, phone, paymentItems);
    console.log('[PAYMENT_NOTIFY] âœ… Email é€šçŸ¥å·²ç™¼é€');
  } catch (emailError) {
    console.error('[PAYMENT_NOTIFY] âŒ Email é€šçŸ¥ç™¼é€å¤±æ•—:', emailError);
  }
  
  return { success: true, message: 'ä»˜æ¬¾é€šçŸ¥å·²é€å‡º' };
}

async function handlePaymentNotification(body, supabase) {
  const { nickname, phone, type, item, cardNo, orderIds, breakId, key, amount, total, quantity, remark, status } = body;
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  
  // ğŸŒŸ 1. å­˜å…¥ä»˜æ¬¾é€šçŸ¥åˆ° notifications è¡¨ï¼ˆç”¨æ–¼å°å¸³ï¼‰
  try {
    const notificationData = {
      user_id: userId,
      type: 'payment', // ä»˜æ¬¾é€šçŸ¥é¡å‹
      subject: `${type === 'order' ? 'è¨‚å–®' : 'åœ˜æ‹†'}ä»˜æ¬¾é€šçŸ¥ - ${nickname}`,
      content: JSON.stringify({
        paymentType: type, // 'order' æˆ– 'break'
        paymentMethod: body.paymentMethod || 'bank', // 'bank' æˆ– 'linepay'
        accountLast5: key, // å¸³è™Ÿå¾Œäº”ç¢¼æˆ– Line Pay åç¨±
        items: item,
        cardNumbers: cardNo || '',
        orderIds: orderIds || '', // è¨‚å–® IDï¼ˆç”¨æ–¼å°å¸³æŸ¥è©¢ï¼‰
        breakIds: breakId || '',
        quantity: quantity,
        paidAmount: amount,
        remark: remark || ''
      }),
      status: 'pending', // å¾…ç¢ºèª
      sent_at: new Date().toISOString()
    };
    
    console.log('[NOTIFICATION] æº–å‚™å¯«å…¥è³‡æ–™:', JSON.stringify(notificationData));
    
    const insertResult = await supabase.insert('notifications', [notificationData]);
    
    console.log('[NOTIFICATION] å¯«å…¥çµæœ:', JSON.stringify(insertResult));
    
    if (insertResult && insertResult.error) {
      console.error('[NOTIFICATION] å¯«å…¥å¤±æ•—:', JSON.stringify(insertResult.error));
      return { success: false, message: 'ä»˜æ¬¾é€šçŸ¥å¯«å…¥å¤±æ•—: ' + insertResult.error.message };
    }
    
    console.log('[NOTIFICATION] âœ… ä»˜æ¬¾é€šçŸ¥å¯«å…¥æˆåŠŸ');
    
  } catch (error) {
    console.error('[NOTIFICATION] å­˜å…¥ä»˜æ¬¾é€šçŸ¥ç•°å¸¸:', error.toString());
    return { success: false, message: 'ä»˜æ¬¾é€šçŸ¥å­˜å…¥ç•°å¸¸: ' + error.message };
  }
  
  // ğŸŒŸ 2. æ ¹æ“šä»˜æ¬¾é¡å‹æ›´æ–°è¨‚å–®/åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
  if (type === 'order') {
    // è¨‚å–®ä»˜æ¬¾ - æ ¹æ“šè¨‚å–® ID æ›´æ–°ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
    if (orderIds) {
      const orderIdList = orderIds.split('||').filter(id => id);
      
      console.log('[NOTIFICATION] æº–å‚™æ›´æ–°è¨‚å–®ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€ï¼Œè¨‚å–® ID:', orderIdList);
      
      for (const orderId of orderIdList) {
        try {
          const updateUrl = `${supabase.url}/rest/v1/orders?id=eq.${orderId}`;
          
          const updateResponse = await fetch(updateUrl, {
            method: 'PATCH',
            headers: {
              'apikey': supabase.apiKey,
              'Authorization': `Bearer ${supabase.apiKey}`,
              'Content-Type': 'application/json',
              'Prefer': 'return=representation'
            },
            body: JSON.stringify({ status: 'ä»˜æ¬¾ç¢ºèªä¸­' })
          });
          
          if (!updateResponse.ok) {
            console.error('[NOTIFICATION] æ›´æ–°è¨‚å–® ID ' + orderId + ' HTTP éŒ¯èª¤:', updateResponse.status, updateResponse.statusText);
          }
          
          const updateResult = await updateResponse.json();
          console.log('[NOTIFICATION] è¨‚å–® ID ' + orderId + ' æ›´æ–°çµæœ:', JSON.stringify(updateResult));
          console.log('[NOTIFICATION] è¨‚å–® ID ' + orderId + ' æ›´æ–°å¾Œç­†æ•¸:', Array.isArray(updateResult) ? updateResult.length : 0);
          
        } catch (error) {
          console.error('[NOTIFICATION] æ›´æ–°è¨‚å–® ID ' + orderId + ' ç•°å¸¸:', error.toString());
        }
      }
    } else {
      console.warn('[NOTIFICATION] æ²’æœ‰æ”¶åˆ° orderIds åƒæ•¸');
    }
    
  } else if (type === 'break') {
    // åœ˜æ‹†ä»˜æ¬¾ - æ›´æ–°åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
    if (breakId) {
      const breakIdList = breakId.split('||').filter(id => id);
      
      console.log('[NOTIFICATION] æº–å‚™æ›´æ–°åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€ï¼Œåœ˜æ‹† ID:', breakIdList, 'ç”¨æˆ¶ID:', userId);
      
      for (const bid of breakIdList) {
        try {
          // ğŸ”¥ å…ˆç”¨ break_id å’Œ user_id æŸ¥è©¢æ‰¾åˆ° UUIDï¼ˆé‡é»ï¼šåŠ ä¸Š user_id éæ¿¾ï¼ï¼‰
          const findUrl = `${supabase.url}/rest/v1/breaks?break_id=eq.${encodeURIComponent(bid)}&user_id=eq.${userId}&select=id`;
          
          const findResponse = await fetch(findUrl, {
            headers: {
              'apikey': supabase.apiKey,
              'Authorization': `Bearer ${supabase.apiKey}`,
              'Content-Type': 'application/json'
            }
          });
          
          const findResult = await findResponse.json();
          console.log('[NOTIFICATION] æŸ¥è©¢åœ˜æ‹† break_id:', bid, 'ç”¨æˆ¶:', userId, 'æ‰¾åˆ°:', findResult);
          
          if (Array.isArray(findResult) && findResult.length > 0) {
            const breakUUID = findResult[0].id;
            
            // ä½¿ç”¨ UUID æ›´æ–°ç‰¹å®šçš„åœ˜æ‹†
            const updateUrl = `${supabase.url}/rest/v1/breaks?id=eq.${breakUUID}`;
            
            const updateResponse = await fetch(updateUrl, {
              method: 'PATCH',
              headers: {
                'apikey': supabase.apiKey,
                'Authorization': `Bearer ${supabase.apiKey}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=representation'
              },
              body: JSON.stringify({ status: 'ä»˜æ¬¾ç¢ºèªä¸­' })
            });
            
            if (!updateResponse.ok) {
              console.error('[NOTIFICATION] æ›´æ–°åœ˜æ‹† UUID ' + breakUUID + ' HTTP éŒ¯èª¤:', updateResponse.status, updateResponse.statusText);
            }
            
            const updateResult = await updateResponse.json();
            console.log('[NOTIFICATION] åœ˜æ‹† UUID ' + breakUUID + ' æ›´æ–°çµæœ:', JSON.stringify(updateResult));
          } else {
            console.warn('[NOTIFICATION] æœªæ‰¾åˆ°åœ˜æ‹† break_id:', bid, 'æ–¼ç”¨æˆ¶:', userId);
          }
          
        } catch (error) {
          console.error('[NOTIFICATION] æ›´æ–°åœ˜æ‹† ID ' + bid + ' ç•°å¸¸:', error.toString());
        }
      }
    } else {
      console.warn('[NOTIFICATION] æ²’æœ‰æ”¶åˆ° breakId åƒæ•¸');
    }
  }
  
  // ğŸ“§ å¯„é€ email é€šçŸ¥å•†å®¶
  try {
    // çµ„è£ä»˜æ¬¾é …ç›®è³‡æ–™ä»¥ç¬¦åˆ sendPaymentNotificationEmail çš„æ ¼å¼
    const paymentItems = [{
      item: item,
      amount: amount,
      accountLast5: key,
      date: new Date().toLocaleDateString('zh-TW'),
      note: remark || ''
    }];
    
    await sendPaymentNotificationEmail(nickname, phone, paymentItems);
    console.log('[PAYMENT_NOTIFY] âœ… Email é€šçŸ¥å·²ç™¼é€');
  } catch (emailError) {
    console.error('[PAYMENT_NOTIFY] âŒ Email é€šçŸ¥ç™¼é€å¤±æ•—:', emailError);
    // Email å¤±æ•—ä¸å½±éŸ¿ä»˜æ¬¾é€šçŸ¥åŠŸèƒ½
  }
  
  return { success: true, message: 'ä»˜æ¬¾é€šçŸ¥å·²é€å‡º' };
}

async function handleNotifyProfileUpdate(body, supabase) {
  const { phone, nickname, email, address, realName } = body;
  
  const updateData = {};
  if (nickname) updateData.nickname = nickname;
  if (email) updateData.email = email;
  if (address) updateData.address = address;
  if (realName) updateData.real_name = realName;
  
  const updateUrl = `${supabase.url}/rest/v1/users?phone=eq.${phone}`;
  const response = await fetch(updateUrl, {
    method: 'PATCH',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    },
    body: JSON.stringify(updateData)
  });
  
  const result = await response.json();
  return { success: true, message: 'å€‹äººè³‡æ–™æ›´æ–°æˆåŠŸ', user: result[0] };
}

async function handleLookupOrderStatus(body, supabase) {
  const { query } = body;
  
  const users = await supabase.query('users', { eq: { phone: query } });
  
  if (users && users.length > 0) {
    const userId = users[0].id;
    
    const ordersUrl = `${supabase.url}/rest/v1/orders?user_id=eq.${userId}&order=timestamp.desc&limit=20&select=*`;
    const ordersResp = await fetch(ordersUrl, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`
      }
    });
    const orders = await ordersResp.json();
    
    const breaksUrl = `${supabase.url}/rest/v1/breaks?user_id=eq.${userId}&order=created_at.desc&limit=20&select=*`;
    const breaksResp = await fetch(breaksUrl, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`
      }
    });
    const breaks = await breaksResp.json();
    
    return {
      success: true,
      orders: (orders || []).map(o => ({
        item: o.item,
        cardNo: o.card_no,
        totalFee: o.total_fee,
        balanceAmount: o.balance_amount,
        status: o.status,
        timestamp: o.timestamp
      })),
      breaks: (breaks || []).map(b => ({
        breakId: b.break_id,
        name: b.name,
        totalFee: b.total_fee,
        balance: b.balance,
        createdAt: b.created_at
      }))
    };
  }
  
  return { success: true, orders: [], breaks: [] };
}

async function handleGetBreakCredit(body, supabase) {
  const { nickname, phone } = body;
  
  const orCondition = `nickname.eq.${nickname},phone.eq.${phone}`;
  const usersUrl = `${supabase.url}/rest/v1/users?or=(${orCondition})&select=*`;
  const usersResp = await fetch(usersUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const users = await usersResp.json();
  
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  const credits = await supabase.query('break_credits', { eq: { user_id: userId } });
  
  let total = 0;
  let used = 0;
  let breakCreditHistory = [];
  
  if (credits && Array.isArray(credits)) {
    credits.forEach(c => {
      total += c.amount || 0;
      used += c.used_amount || 0;
      
      // å»ºç«‹æ­·å²è¨˜éŒ„
      breakCreditHistory.push({
        amount: c.amount || 0,
        source: c.source || 'åœ˜æ‹†å›é¥‹',
        used: c.is_used || false,
        usedAmount: c.used_amount || 0,
        remaining: (c.amount || 0) - (c.used_amount || 0),
        usedBreak: c.used_break_ids || null
      });
    });
  }
  
  return {
    success: true,
    credit: total,  // å‰ç«¯æœŸæœ›çš„æ¬„ä½åç¨±
    total,          // ä¿ç•™å‘å¾Œç›¸å®¹
    used,
    available: total - used,
    breakCreditHistory
  };
}

async function handleUseBreakCredit(body, supabase) {
  const { nickname, phone, amount, breakIds } = body;
  
  const orCondition = `nickname.eq.${nickname},phone.eq.${phone}`;
  const usersUrl = `${supabase.url}/rest/v1/users?or=(${orCondition})&select=*`;
  const usersResp = await fetch(usersUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const users = await usersResp.json();
  
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  
  const creditsUrl = `${supabase.url}/rest/v1/break_credits?user_id=eq.${userId}&select=*`;
  const creditsResp = await fetch(creditsUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const credits = await creditsResp.json();
  
  console.log('[useBreakCredit] æŸ¥è©¢åˆ°çš„åœ˜æ‹†é‡‘è¨˜éŒ„æ•¸:', credits.length);
  
  let available = 0;
  if (credits && Array.isArray(credits)) {
    credits.forEach(c => {
      const remaining = (c.amount || 0) - (c.used_amount || 0);
      console.log('[useBreakCredit] åœ˜æ‹†é‡‘è¨˜éŒ„ ID:', c.id, 'ç¸½é¡:', c.amount, 'å·²ç”¨:', c.used_amount, 'å‰©é¤˜:', remaining);
      if (remaining > 0) {
        available += remaining;
      }
    });
  }
  
  console.log('[useBreakCredit] å¯ç”¨ç¸½é¡:', available, 'è¦ä½¿ç”¨:', amount);
  
  if (available < amount) {
    return { success: false, message: 'åœ˜æ‹†é‡‘é¤˜é¡ä¸è¶³' };
  }
  
  // æ‰¾åˆ°ç¬¬ä¸€å€‹æœ‰é¤˜é¡çš„åœ˜æ‹†é‡‘è¨˜éŒ„
  let remainingAmount = amount;
  
  for (const credit of credits) {
    if (remainingAmount <= 0) break;
    
    const creditRemaining = (credit.amount || 0) - (credit.used_amount || 0);
    if (creditRemaining <= 0) continue;
    
    const amountToUse = Math.min(remainingAmount, creditRemaining);
    const newUsedAmount = (credit.used_amount || 0) + amountToUse;
    
    console.log('[useBreakCredit] è™•ç†è¨˜éŒ„ ID:', credit.id, 'è¦ç”¨:', amountToUse, 'æ–°å·²ç”¨é‡:', newUsedAmount);
    
    // ğŸŒŸ åˆä½µ breakIds ä¸¦è¨˜éŒ„é‡‘é¡ (æ ¼å¼: "breakId@@breakName::amount")
    const existingBreakIds = credit.used_break_ids || '';
    const breakIdWithAmount = `${breakIds}::${amountToUse}`;
    const newBreakIds = existingBreakIds ? `${existingBreakIds}||${breakIdWithAmount}` : breakIdWithAmount;
    
    const updateUrl = `${supabase.url}/rest/v1/break_credits?id=eq.${credit.id}`;
    await fetch(updateUrl, {
      method: 'PATCH',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        used_amount: newUsedAmount,
        is_used: newUsedAmount >= credit.amount,
        used_break_ids: newBreakIds
      })
    });
    
    remainingAmount -= amountToUse;
  }
  
  return { success: true, message: 'åœ˜æ‹†é‡‘ä½¿ç”¨æˆåŠŸ' };
}

// ===== åœ˜æ‹†é‡‘ç®¡ç† API =====

async function handleGetAllBreakCredits(body, supabase) {
  const { nickname } = body;
  
  let url = `${supabase.url}/rest/v1/break_credits?select=*,users!inner(nickname)`;
  
  if (nickname && nickname.trim() !== '') {
    url += `&users.nickname=ilike.*${nickname}*`;
  }
  
  const response = await fetch(url, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  const data = await response.json();
  
  if (!response.ok) {
    return { success: false, message: 'æŸ¥è©¢å¤±æ•—', credits: [] };
  }
  
  // è½‰æ›è³‡æ–™æ ¼å¼ï¼Œå°‡users.nicknameæå–åˆ°é ‚å±¤
  const credits = data.map(item => ({
    id: item.id,
    user_id: item.user_id,
    nickname: item.users?.nickname || 'æœªçŸ¥',
    credit: item.amount || 0,
    usedAmount: item.used_amount || 0,
    source: item.source || '',
    used: item.is_used || false,
    usedBreak: item.used_break_ids || null
  }));
  
  return { success: true, credits };
}

async function handleAddBreakCredit(body, supabase) {
  const { nickname, credit, source } = body;
  
  if (!nickname || !credit || credit <= 0) {
    return { success: false, message: 'è«‹æä¾›æœ‰æ•ˆçš„æš±ç¨±å’Œé‡‘é¡' };
  }
  
  // æŸ¥è©¢ç”¨æˆ¶ID
  const usersUrl = `${supabase.url}/rest/v1/users?nickname=eq.${encodeURIComponent(nickname)}&select=id`;
  const usersResp = await fetch(usersUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  const users = await usersResp.json();
  
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°è©²æš±ç¨±çš„ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  
  // æ–°å¢åœ˜æ‹†é‡‘è¨˜éŒ„
  const insertUrl = `${supabase.url}/rest/v1/break_credits`;
  const insertResp = await fetch(insertUrl, {
    method: 'POST',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    },
    body: JSON.stringify({
      user_id: userId,
      amount: credit,
      source: source || 'ç®¡ç†å“¡æ–°å¢',
      used_amount: 0,
      is_used: false
    })
  });
  
  if (!insertResp.ok) {
    const error = await insertResp.text();
    return { success: false, message: 'æ–°å¢å¤±æ•—: ' + error };
  }
  
  return { success: true, message: 'åœ˜æ‹†é‡‘æ–°å¢æˆåŠŸ' };
}

async function handleBatchAddBreakCredit(body, supabase) {
  const { nicknames, credit, source } = body;
  
  if (!nicknames || !Array.isArray(nicknames) || nicknames.length === 0) {
    return { success: false, message: 'è«‹æä¾›æš±ç¨±åˆ—è¡¨' };
  }
  
  if (!credit || credit <= 0) {
    return { success: false, message: 'è«‹æä¾›æœ‰æ•ˆçš„é‡‘é¡' };
  }
  
  let successCount = 0;
  let failCount = 0;
  let failedNicknames = [];
  
  // é€ä¸€è™•ç†æ¯å€‹æš±ç¨±
  for (const nickname of nicknames) {
    try {
      // æŸ¥è©¢ç”¨æˆ¶ID
      const usersUrl = `${supabase.url}/rest/v1/users?nickname=eq.${encodeURIComponent(nickname)}&select=id`;
      const usersResp = await fetch(usersUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      
      const users = await usersResp.json();
      
      if (!users || users.length === 0) {
        failCount++;
        failedNicknames.push(nickname + '(æ‰¾ä¸åˆ°ç”¨æˆ¶)');
        continue;
      }
      
      const userId = users[0].id;
      
      // æ–°å¢åœ˜æ‹†é‡‘è¨˜éŒ„
      const insertUrl = `${supabase.url}/rest/v1/break_credits`;
      const insertResp = await fetch(insertUrl, {
        method: 'POST',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        },
        body: JSON.stringify({
          user_id: userId,
          amount: credit,
          source: source || 'æ‰¹é‡æ–°å¢',
          used_amount: 0,
          is_used: false
        })
      });
      
      if (insertResp.ok) {
        successCount++;
      } else {
        failCount++;
        failedNicknames.push(nickname + '(æ–°å¢å¤±æ•—)');
      }
    } catch (error) {
      failCount++;
      failedNicknames.push(nickname + '(éŒ¯èª¤: ' + error.message + ')');
    }
  }
  
  return {
    success: true,
    message: `æ‰¹é‡æ–°å¢å®Œæˆ: æˆåŠŸ ${successCount} å€‹ï¼Œå¤±æ•— ${failCount} å€‹`,
    successCount,
    failCount,
    failedNicknames
  };
}

async function handleUpdateBreakCredit(body, supabase) {
  const { id, credit, source } = body;
  
  if (!id || !credit || credit <= 0) {
    return { success: false, message: 'è«‹æä¾›æœ‰æ•ˆçš„IDå’Œé‡‘é¡' };
  }
  
  const updateUrl = `${supabase.url}/rest/v1/break_credits?id=eq.${id}`;
  const updateResp = await fetch(updateUrl, {
    method: 'PATCH',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      amount: credit,
      source: source || 'ç®¡ç†å“¡ç·¨è¼¯'
    })
  });
  
  if (!updateResp.ok) {
    const error = await updateResp.text();
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + error };
  }
  
  return { success: true, message: 'åœ˜æ‹†é‡‘æ›´æ–°æˆåŠŸ' };
}

async function handleDeleteBreakCredit(body, supabase) {
  const { id } = body;
  
  console.log('[deleteBreakCredit] æ”¶åˆ°åˆªé™¤è«‹æ±‚ï¼ŒID:', id);
  
  if (!id) {
    return { success: false, message: 'è«‹æä¾›æœ‰æ•ˆçš„ID' };
  }
  
  // å…ˆæª¢æŸ¥è©²è¨˜éŒ„æ˜¯å¦å­˜åœ¨
  const checkUrl = `${supabase.url}/rest/v1/break_credits?id=eq.${id}&select=*`;
  const checkResp = await fetch(checkUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  const records = await checkResp.json();
  console.log('[deleteBreakCredit] æŸ¥è©¢çµæœ:', records);
  
  if (!Array.isArray(records) || records.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°è©²åœ˜æ‹†é‡‘è¨˜éŒ„' };
  }
  
  const record = records[0];
  console.log('[deleteBreakCredit] æº–å‚™åˆªé™¤è¨˜éŒ„:', { id: record.id, used: record.is_used, usedAmount: record.used_amount });
  
  const deleteUrl = `${supabase.url}/rest/v1/break_credits?id=eq.${id}`;
  const deleteResp = await fetch(deleteUrl, {
    method: 'DELETE',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  console.log('[deleteBreakCredit] åˆªé™¤å›æ‡‰ç‹€æ…‹:', deleteResp.status);
  
  if (!deleteResp.ok) {
    const error = await deleteResp.text();
    console.error('[deleteBreakCredit] åˆªé™¤å¤±æ•—:', error);
    return { success: false, message: 'åˆªé™¤å¤±æ•—: ' + error };
  }
  
  return { success: true, message: 'åœ˜æ‹†é‡‘åˆªé™¤æˆåŠŸ' };
}

// ===== åœ˜æ‹†é‡‘ç®¡ç† API çµæŸ =====

async function handleSubmitPsaOrder(body, supabase) {
  const { formData } = body;
  
  const users = await supabase.query('users', { eq: { phone: formData.phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  const orderId = 'PSA' + Date.now();
  
  const psaOrder = [{
    user_id: userId,
    order_id: orderId,
    real_name: formData.realName,
    email: formData.email,
    phone: formData.phone,
    shipping_method: formData.shippingMethod,
    total_cards: formData.totalCards,
    total_amount: formData.totalAmount,
    status: 'è™•ç†ä¸­',
    timestamp: new Date().toISOString()
  }];
  
  const result = await supabase.insert('psa_orders', psaOrder);
  
  if (result && result.length > 0) {
    return { success: true, message: 'PSA è¨‚å–®æäº¤æˆåŠŸ', orderId: orderId };
  }
  
  return { success: false, message: 'PSA è¨‚å–®æäº¤å¤±æ•—' };
}

async function handleLookupPsaOrders(body, supabase) {
  const { phone } = body;
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  
  const ordersUrl = `${supabase.url}/rest/v1/psa_orders?user_id=eq.${userId}&order=timestamp.desc&select=*`;
  const ordersResp = await fetch(ordersUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const orders = await ordersResp.json();
  
  return {
    success: true,
    orders: (orders || []).map(o => ({
      orderId: o.order_id,
      realName: o.real_name,
      totalCards: o.total_cards,
      totalAmount: o.total_amount,
      status: o.status,
      timestamp: o.timestamp
    }))
  };
}

async function handleCheckDailyFortune(body, supabase) {
  const { phone } = body;
  
  console.log('ğŸ” checkDailyFortune - phone:', phone);
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    console.log('âŒ æ‰¾ä¸åˆ°ç”¨æˆ¶');
    return { success: false, hasDrawn: false };
  }
  
  const userId = users[0].id;
  console.log('âœ… æ‰¾åˆ°ç”¨æˆ¶ ID:', userId);
  
  // ğŸ”§ å–å¾—å°ç£æ™‚é–“çš„ä»Šå¤©æ—¥æœŸç¯„åœ (UTC+8)
  const now = new Date();
  const taiwanOffset = 8 * 60; // å°ç£ UTC+8ï¼Œåˆ†é˜æ•¸
  const taiwanTime = new Date(now.getTime() + taiwanOffset * 60 * 1000);
  
  // å–å¾—å°ç£æ™‚é–“çš„å¹´æœˆæ—¥
  const year = taiwanTime.getUTCFullYear();
  const month = taiwanTime.getUTCMonth();
  const date = taiwanTime.getUTCDate();
  
  // å»ºç«‹å°ç£æ™‚é–“çš„ä»Šå¤© 00:00 å’Œæ˜å¤© 00:00 (UTC æ™‚é–“)
  const todayTaiwanMidnight = new Date(Date.UTC(year, month, date, 0, 0, 0) - taiwanOffset * 60 * 1000);
  const tomorrowTaiwanMidnight = new Date(todayTaiwanMidnight.getTime() + 24 * 60 * 60 * 1000);
  
  const todayStr = todayTaiwanMidnight.toISOString();
  const tomorrowStr = tomorrowTaiwanMidnight.toISOString();
  
  console.log('ğŸ“… å°ç£æ™‚é–“:', taiwanTime.toISOString());
  console.log('ğŸ“… æŸ¥è©¢æ—¥æœŸç¯„åœ:', todayStr, '~', tomorrowStr);
  
  // æŸ¥è©¢ä»Šå¤©æ˜¯å¦æœ‰æŠ½ç±¤è¨˜éŒ„ (ä½¿ç”¨ result å’Œ draw_date æ¬„ä½)
  const fortuneUrl = `${supabase.url}/rest/v1/lottery?user_id=eq.${userId}&draw_date=gte.${todayStr}&draw_date=lt.${tomorrowStr}&select=result,draw_date,created_at`;
  const fortuneResp = await fetch(fortuneUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  if (!fortuneResp.ok) {
    const errorText = await fortuneResp.text();
    console.error('âŒ æŸ¥è©¢å¤±æ•—:', fortuneResp.status, errorText);
    return { success: false, hasDrawn: false };
  }
  
  const fortune = await fortuneResp.json();
  console.log('ğŸ“Š æŸ¥è©¢çµæœ:', fortune);
  
  if (fortune && fortune.length > 0) {
    console.log('âœ… ä»Šå¤©å·²æŠ½é:', fortune[0].result);
    return {
      success: true,
      hasDrawn: true,
      lastResult: fortune[0].result
    };
  }
  
  console.log('âœ… ä»Šå¤©é‚„æ²’æŠ½é');
  return {
    success: true,
    hasDrawn: false
  };
}

async function handleSaveDailyFortune(body, supabase) {
  const { phone, nickname, result } = body;
  
  console.log('ğŸ“ saveDailyFortune - phone:', phone, 'result:', result);
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    console.log('âŒ æ‰¾ä¸åˆ°ç”¨æˆ¶:', phone);
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  console.log('âœ… æ‰¾åˆ°ç”¨æˆ¶ ID:', userId);
  
  // ğŸ”§ ä½¿ç”¨å°ç£æ™‚é–“ (UTC+8)
  const now = new Date();
  const taiwanOffset = 8 * 60; // å°ç£ UTC+8ï¼Œåˆ†é˜æ•¸
  const taiwanTime = new Date(now.getTime() + taiwanOffset * 60 * 1000);
  
  console.log('ğŸ“… å°ç£æ™‚é–“:', taiwanTime.toISOString());
  
  // ä½¿ç”¨æ–°çš„è¡¨çµæ§‹ï¼šresult (é‹å‹¢çµæœ), draw_date (æŠ½ç±¤æ™‚é–“), status (ç‹€æ…‹)
  const lotteryRecord = {
    user_id: userId,
    result: result,
    draw_date: taiwanTime.toISOString(),  // ä½¿ç”¨å°ç£æ™‚é–“
    status: 'å·²å®Œæˆ'
  };
  
  console.log('ğŸ’¾ æº–å‚™æ’å…¥è¨˜éŒ„:', lotteryRecord);
  
  try {
    const insertResult = await supabase.insert('lottery', [lotteryRecord]);
    console.log('âœ… æ’å…¥çµæœ:', insertResult);
    
    // æª¢æŸ¥æ˜¯å¦æœ‰éŒ¯èª¤
    if (insertResult && insertResult.error) {
      console.error('âŒ æ’å…¥æ™‚ç™¼ç”ŸéŒ¯èª¤:', insertResult.error);
      return { success: false, message: 'å„²å­˜å¤±æ•—: ' + insertResult.error.message };
    }
    
    return { success: true, message: 'æŠ½ç±¤çµæœå·²å„²å­˜' };
  } catch (error) {
    console.error('âŒ æ’å…¥å¤±æ•—:', error);
    return { success: false, message: 'å„²å­˜å¤±æ•—: ' + error.message };
  }
}

async function handleCreateShipmentRecord(body, supabase) {
  const { phone, shipmentData } = body;
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  
  const shipment = [{
    user_id: userId,
    shipment_no: shipmentData.shipmentNo,
    shipment_date: getTaiwanTimeISO(), // ğŸ”§ ä½¿ç”¨å°ç£æ™‚é–“
    tracking_no: shipmentData.trackingNo,
    items: shipmentData.items,
    status: 'å·²å‡ºè²¨'
  }];
  
  const result = await supabase.insert('shipments', shipment);
  return { success: true, message: 'å‡ºè²¨è¨˜éŒ„å·²å»ºç«‹', shipment: result[0] };
}

async function handleGetShipmentRecords(body, supabase) {
  const { phone } = body;
  
  const users = await supabase.query('users', { eq: { phone } });
  if (!users || users.length === 0) {
    return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
  }
  
  const userId = users[0].id;
  
  const shipmentsUrl = `${supabase.url}/rest/v1/shipments?user_id=eq.${userId}&order=shipment_date.desc&select=*`;
  const shipmentsResp = await fetch(shipmentsUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  const shipments = await shipmentsResp.json();
  
  const records = (shipments || []).map(s => {
    // è™•ç† items æ ¼å¼ï¼šå¦‚æœæ˜¯é™£åˆ—è½‰æˆæ›è¡Œå­—ä¸²ï¼Œå¦‚æœæ˜¯åˆ†è™Ÿåˆ†éš”è½‰æˆæ›è¡Œ
    let itemsStr = s.items;
    if (Array.isArray(s.items)) {
      itemsStr = s.items.join('\\n');
    } else if (typeof s.items === 'string' && s.items.includes('; ')) {
      itemsStr = s.items.split('; ').join('\\n');
    }
    
    return {
      shipmentNumber: s.shipment_no || '',  // å‰ç«¯æœŸæœ› shipmentNumber
      shipmentNo: s.shipment_no || '',       // ä¿ç•™å‘å¾Œå…¼å®¹
      trackingNumber: s.tracking_no || '',   // å‰ç«¯æœŸæœ› trackingNumber
      items: itemsStr || '',
      status: s.status || '',
      shipmentDate: s.shipment_date || '',
      shipStore: s.ship_store || '',         // 711 åº—å
      storeNumber: s.store_number || '',     // åº—è™Ÿ
      note: s.remark || ''                   // å‚™è¨»æ¬„ä½
    };
  });
  
  return {
    success: true,
    records: records  // å‰ç«¯æœŸæœ› records æ¬„ä½
  };
}

async function handleCreateEcpayPayment(body, supabase) {
  try {
    const { orderDetails, totalAmount, phone, nickname, orderIds, itemName, paymentType } = body;
    
    if (!phone || !totalAmount) {
      return { success: false, message: 'ç¼ºå°‘å¿…è¦åƒæ•¸ï¼šphone æˆ– totalAmount' };
    }
    
    // é©—è­‰é‡‘é¡
    const amount = Number(totalAmount);
    if (amount < 1 || amount > 20000) {
      return { success: false, message: 'æ¸¬è©¦ç’°å¢ƒé‡‘é¡ç¯„åœ: NT$1 - NT$20,000' };
    }
    
    // å…ˆæŸ¥è©¢ä½¿ç”¨è€…IDï¼ˆæ ¹æ“šphoneï¼‰- é€™å¿…é ˆå…ˆåšï¼Œå› ç‚ºå¾Œé¢éœ€è¦ user_id
    console.log('[ECPay] æŸ¥è©¢ä½¿ç”¨è€…:', phone);
    const users = await supabase.query('users', { eq: { phone: phone } });
    console.log('[ECPay] æŸ¥è©¢çµæœ:', users);
    
    if (!Array.isArray(users) || users.length === 0) {
      console.error('[ECPay] æ‰¾ä¸åˆ°è©²é›»è©±è™Ÿç¢¼çš„ä½¿ç”¨è€…:', phone);
      return { success: false, message: 'æ‰¾ä¸åˆ°è©²ä½¿ç”¨è€…ï¼Œè«‹å…ˆç™»å…¥' };
    }
    const userId = users[0].id;
    console.log('[ECPay] æ‰¾åˆ°ä½¿ç”¨è€…:', userId);
    
    // ç”¢ç”Ÿè¨‚å–®ç·¨è™Ÿ
    const merchantTradeNo = 'NC' + Date.now();
    
    // ç¶ ç•Œè¦æ±‚çš„æ™‚é–“æ ¼å¼: yyyy/MM/dd HH:mm:ss (ä½¿ç”¨æœ¬åœ°æ™‚é–“ GMT+8)
    const now = new Date();
    // è½‰æ›ç‚º GMT+8 æ™‚é–“
    const localTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
    const year = localTime.getUTCFullYear();
    const month = String(localTime.getUTCMonth() + 1).padStart(2, '0');
    const day = String(localTime.getUTCDate()).padStart(2, '0');
    const hours = String(localTime.getUTCHours()).padStart(2, '0');
    const minutes = String(localTime.getUTCMinutes()).padStart(2, '0');
    const seconds = String(localTime.getUTCSeconds()).padStart(2, '0');
    const tradeDate = `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
    
    console.log('[ECPay] ç”¢ç”Ÿäº¤æ˜“æ™‚é–“:', tradeDate, '(GMT+8)');
    
    // çµ„åˆç¶ ç•Œåƒæ•¸
    const ecpayParams = {
      MerchantID: ECPAY_CONFIG.MerchantID,
      MerchantTradeNo: merchantTradeNo,
      MerchantTradeDate: tradeDate,
      PaymentType: 'aio',
      TotalAmount: Math.round(amount),
      TradeDesc: 'NingsCard Order',
      ItemName: (itemName || 'å•†å“è¨‚å–®').substring(0, 200),
      ReturnURL: 'https://supabase.cnkuoc.workers.dev/ecpay-callback',  // ç¶ ç•Œä»˜æ¬¾å®Œæˆå¾Œå›èª¿æ­¤ç«¯é»
      ChoosePayment: ECPAY_CONFIG.ChoosePayment,
      EncryptType: ECPAY_CONFIG.EncryptType,
      CustomField1: phone,
      CustomField2: (orderIds || []).join(','),
      ClientBackURL: 'https://supabasedemo-dnd.pages.dev/'  // å®¢æˆ¶è¿”å›å•†åº—é¦–é 
    };
    
    console.log('[ECPay] çµ„åˆåƒæ•¸å®Œæˆï¼Œæº–å‚™ç”Ÿæˆ CheckMacValue');
    
    // ç”Ÿæˆ CheckMacValue (éåŒæ­¥)
    const checkMacValue = await generateEcpayCheckMacValueAsync(ecpayParams);
    ecpayParams.CheckMacValue = checkMacValue;
    
    console.log('[ECPay] CheckMacValue ç”Ÿæˆå®Œæˆ:', checkMacValue.substring(0, 20) + '...');
    
    // å„²å­˜ä»˜æ¬¾è¨˜éŒ„åˆ° ecpay_records è¡¨ï¼ˆä½¿ç”¨é‡æ–°å‘½åå¾Œçš„æ¬„ä½åï¼‰
    const paymentRecord = {
      merchant_trade_no: merchantTradeNo,
      user_id: userId,
      trade_amt: amount,
      item_name: itemName || 'å•†å“è¨‚å–®',
      status: 'pending',
      order_details: JSON.stringify(orderDetails || []),
      payment_type: paymentType || 'order',
      order_ids: (orderIds || []).join(','),
      trade_date: new Date().toISOString(),
      created_at: new Date().toISOString()
    };
    
    console.log('[ECPay] å„²å­˜ä»˜æ¬¾è¨˜éŒ„åˆ°è³‡æ–™åº«...');
    console.log('[ECPay] è¨˜éŒ„:', paymentRecord);
    
    try {
      // ä½¿ç”¨ fetch ç›´æ¥æ’å…¥ï¼Œæ¯” supabase.insert() æ›´å¯é 
      const insertUrl = `${supabase.url}/rest/v1/ecpay_records`;
      console.log('[ECPay] æ’å…¥ URL:', insertUrl);
      
      const insertResponse = await fetch(insertUrl, {
        method: 'POST',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        },
        body: JSON.stringify(paymentRecord)
      });
      
      console.log('[ECPay] æ’å…¥ HTTP ç‹€æ…‹:', insertResponse.status);
      
      const insertResult = await insertResponse.json();
      console.log('[ECPay] æ’å…¥çµæœé¡å‹:', typeof insertResult);
      console.log('[ECPay] æ’å…¥çµæœ:', JSON.stringify(insertResult).substring(0, 500));
      
      if (insertResponse.ok) {
        console.log('[ECPay] âœ… ä»˜æ¬¾è¨˜éŒ„å·²æˆåŠŸå„²å­˜åˆ° ecpay_records è¡¨');
      } else {
        console.error('[ECPay] âš ï¸ æ’å…¥å¤±æ•—ï¼ŒHTTP ' + insertResponse.status, insertResult);
      }
    } catch (dbError) {
      console.error('[ECPay] âš ï¸ è³‡æ–™åº«ç•°å¸¸:', dbError.message || JSON.stringify(dbError));
      // ä¸è¦ returnï¼Œç¹¼çºŒç”Ÿæˆä»˜æ¬¾è¡¨å–®
    }
    
    console.log('[ECPay] âœ… æº–å‚™è¿”å›æ”¯ä»˜åƒæ•¸');
    
    return {
      success: true,
      paymentUrl: ECPAY_CONFIG.PaymentURL,
      params: ecpayParams,
      merchantTradeNo: merchantTradeNo,
      message: 'ä»˜æ¬¾è³‡è¨Šå·²å»ºç«‹'
    };
  } catch (error) {
    console.error('[ECPay] å»ºç«‹ä»˜æ¬¾å¤±æ•—:', error);
    return { success: false, message: 'å»ºç«‹ä»˜æ¬¾å¤±æ•—: ' + error.message };
  }
}

async function handleCheckPaymentStatus(body, supabase) {
  const { merchantTradeNo } = body;
  
  console.log('[Payment] æŸ¥è©¢æ”¯ä»˜ç‹€æ…‹:', merchantTradeNo);
  
  // ä½¿ç”¨ fetch ç›´æ¥æŸ¥è©¢ï¼Œæ¯”ç”¨ supabase.query() æ›´å¯é 
  const queryUrl = `${supabase.url}/rest/v1/ecpay_records?merchant_trade_no=eq.${encodeURIComponent(merchantTradeNo)}&select=*`;
  console.log('[Payment] æŸ¥è©¢ URL:', queryUrl);
  
  const queryResp = await fetch(queryUrl, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    }
  });
  
  const payment = await queryResp.json();
  console.log('[Payment] æŸ¥è©¢çµæœ:', Array.isArray(payment) ? payment.length + 'ç­†' : JSON.stringify(payment).substring(0, 200));
  
  if (payment && Array.isArray(payment) && payment.length > 0) {
    const record = payment[0];
    
    return {
      success: true,
      status: record.status,
      paymentDate: record.payment_date
    };
  }
  
  return { success: false, message: 'æ‰¾ä¸åˆ°ä»˜æ¬¾è¨˜éŒ„' };
}

async function handleUpdateOrderStatusToPending(body, supabase) {
  const { orderDetails, merchantTradeNo } = body;
  
  if (!orderDetails || orderDetails.length === 0) {
    return { success: false, message: 'ç¼ºå°‘è¨‚å–®æ˜ç´°' };
  }
  
  let updatedCount = 0;
  
  try {
    // éæ­·æ¯ç­†è¨‚å–®æ˜ç´°ï¼Œæ›´æ–°ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
    for (const detail of orderDetails) {
      const { nickname, timestamp, item, cardNo } = detail;
      
      // æ§‹å»ºæŸ¥è©¢æ¢ä»¶
      const updateUrl = `${supabase.url}/rest/v1/orders?item=eq.${encodeURIComponent(item)}&card_no=eq.${encodeURIComponent(cardNo || '')}`;
      
      // æŸ¥è©¢åŒ¹é…çš„è¨‚å–®
      const ordersResp = await fetch(updateUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      const orders = await ordersResp.json();
      
      // æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„è¨‚å–®ï¼ˆéœ€è¦åŒ¹é…æ™‚é–“æˆ³è¨˜ã€æš±ç¨±ï¼‰
      if (Array.isArray(orders)) {
        for (const order of orders) {
          // é€é user_id æŸ¥è©¢ç”¨æˆ¶æš±ç¨±
          const users = await supabase.query('users', { eq: { id: order.user_id } });
          if (users && users.length > 0 && users[0].nickname === nickname) {
            // æ™‚é–“æˆ³è¨˜åŒ¹é…ï¼ˆè½‰æ›ç‚ºç›¸åŒæ ¼å¼æ¯”è¼ƒï¼‰
            const orderTime = new Date(order.timestamp).toISOString();
            const detailTime = new Date(timestamp).toISOString();
            
            if (orderTime === detailTime) {
              // æ›´æ–°ç‹€æ…‹
              const patchUrl = `${supabase.url}/rest/v1/orders?id=eq.${order.id}`;
              await fetch(patchUrl, {
                method: 'PATCH',
                headers: {
                  'apikey': supabase.apiKey,
                  'Authorization': `Bearer ${supabase.apiKey}`,
                  'Content-Type': 'application/json',
                  'Prefer': 'return=minimal'
                },
                body: JSON.stringify({
                  status: 'ä»˜æ¬¾ç¢ºèªä¸­'
                })
              });
              
              updatedCount++;
              console.log('[UPDATE_ORDER] âœ… å·²æ›´æ–°è¨‚å–®:', item, cardNo, 'ç‹€æ…‹ -> ä»˜æ¬¾ç¢ºèªä¸­');
              break;
            }
          }
        }
      }
    }
    
    console.log('[UPDATE_ORDER] å®Œæˆï¼æˆåŠŸæ›´æ–° ' + updatedCount + '/' + orderDetails.length + ' ç­†');
    
    return {
      success: true,
      message: 'å·²æ›´æ–° ' + updatedCount + ' ç­†è¨‚å–®ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€',
      updatedCount,
      totalRequested: orderDetails.length
    };
  } catch (error) {
    console.error('[UPDATE_ORDER] éŒ¯èª¤:', error);
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + error.toString() };
  }
}

async function handleUpdateBreakStatusToPending(body, supabase) {
  const { breakDetails, orderDetails, merchantTradeNo } = body;
  const details = breakDetails || orderDetails;
  
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('[UPDATE_BREAK] ğŸš€ å‡½æ•¸é–‹å§‹åŸ·è¡Œ');
  console.log('[UPDATE_BREAK] æ¥æ”¶åˆ°çš„ body:', JSON.stringify(body));
  console.log('[UPDATE_BREAK] breakDetails:', breakDetails);
  console.log('[UPDATE_BREAK] orderDetails:', orderDetails);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  if (!details || details.length === 0) {
    return { success: false, message: 'ç¼ºå°‘åœ˜æ‹†æ˜ç´°' };
  }

  let updatedCount = 0;
  const matchDetails = [];
  
  try {
    console.log('[UPDATE_BREAK] é–‹å§‹æ›´æ–°åœ˜æ‹†ç‹€æ…‹ï¼Œå…± ' + details.length + ' ç­†');
    
    // éæ­·æ¯ç­†åœ˜æ‹†æ˜ç´°ï¼Œæ›´æ–°ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€
    for (const detail of details) {
      const { nickname, phone, breakId, userId: detailUserId } = detail;
      
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      console.log('[UPDATE_BREAK] è™•ç†ç¬¬' + (details.indexOf(detail) + 1) + 'ç­†');
      console.log('[UPDATE_BREAK] detail å®Œæ•´å…§å®¹:', JSON.stringify(detail));
      console.log('[UPDATE_BREAK] ğŸ”¥ detail çš„æ‰€æœ‰ keys:', Object.keys(detail).join(','));
      console.log('[UPDATE_BREAK] è§£æçµæœ: userId=' + detailUserId + ', breakId=' + breakId + ', nickname=' + nickname);
      console.log('[UPDATE_BREAK] ğŸ”¥ detail.userId (ç›´æ¥è¨ªå•):', detail.userId);
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      
      if (!breakId) {
        console.warn('[UPDATE_BREAK] âš ï¸ ç¼ºå°‘ breakId');
        matchDetails.push({ breakId, nickname, matched: false, reason: 'ç¼ºå°‘ breakId' });
        continue;
      }
      
      // ğŸ”¥ å„ªå…ˆä½¿ç”¨ userId ç›´æ¥åŒ¹é…ï¼ˆæœ€å¯é çš„æ–¹æ³•ï¼‰
      let userId = detailUserId;
      
      if (!userId) {
        console.error('[UPDATE_BREAK] âŒ userId ç‚ºç©ºï¼Œç„¡æ³•é€²è¡Œç²¾ç¢ºåŒ¹é…!');
        console.error('[UPDATE_BREAK] detail:', JSON.stringify(detail));
        matchDetails.push({ breakId, nickname, matched: false, reason: 'userId ç‚ºç©º - å‰ç«¯æœªå‚³é' });
        continue;
      }
      
      console.log('[UPDATE_BREAK] ğŸ”¥ ä½¿ç”¨ userId é€²è¡Œç²¾ç¢ºåŒ¹é…: ' + userId);
      let phoneQueryResult = null;
      
      // ç›´æ¥ç”¨ userId + breakId é€²è¡Œç²¾ç¢ºæŸ¥è©¢
      const breaksUrl = `${supabase.url}/rest/v1/breaks?select=id,break_id,user_id,name,status&break_id=eq.${encodeURIComponent(breakId)}&user_id=eq.${encodeURIComponent(userId)}`;
      console.log('[UPDATE_BREAK] æŸ¥è©¢ URL:', breaksUrl);
      
      const breaksResp = await fetch(breaksUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      const breaks = await breaksResp.json();
      
      console.log('[UPDATE_BREAK] æŸ¥è©¢çµæœ:', Array.isArray(breaks) ? breaks.length + ' ç­†' : 'éé™£åˆ—æˆ–éŒ¯èª¤', JSON.stringify(breaks));
      
      if (!Array.isArray(breaks) || breaks.length === 0) {
        console.warn('[UPDATE_BREAK] âŒ ç”¨æˆ¶+break_id ç²¾ç¢ºåŒ¹é…å¤±æ•—:', { breakId, userId, nickname });
        
        // ğŸ” è¿½åŠ è¨ºæ–·ï¼šæŸ¥è©¢æ‰€æœ‰è©²ç”¨æˆ¶çš„åœ˜æ‹†
        console.log('[UPDATE_BREAK] ğŸ” è¨ºæ–·ï¼šæŸ¥è©¢è©²ç”¨æˆ¶çš„æ‰€æœ‰åœ˜æ‹†...');
        const allBreaksUrl = `${supabase.url}/rest/v1/breaks?select=id,break_id,user_id,name,status&user_id=eq.${encodeURIComponent(userId)}`;
        const allBreaksResp = await fetch(allBreaksUrl, {
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`
          }
        });
        const allBreaks = await allBreaksResp.json();
        console.log('[UPDATE_BREAK] ğŸ” è©²ç”¨æˆ¶æœ‰ ' + (Array.isArray(allBreaks) ? allBreaks.length : 0) + ' å€‹åœ˜æ‹†');
        if (Array.isArray(allBreaks) && allBreaks.length > 0) {
          allBreaks.forEach((b, i) => {
            console.log('[UPDATE_BREAK] ğŸ” [' + i + '] break_id=' + b.break_id + ', id=' + b.id + ', name=' + b.name);
          });
        }
        
        // ğŸ” å†æŸ¥è©¢ï¼šæ‰€æœ‰è©² break_id çš„åœ˜æ‹†ï¼ˆä¸é™ user_idï¼‰
        console.log('[UPDATE_BREAK] ğŸ” è¨ºæ–·ï¼šæŸ¥è©¢æ‰€æœ‰ break_id=' + breakId + ' çš„åœ˜æ‹†...');
        const allBreaksByIdUrl = `${supabase.url}/rest/v1/breaks?select=id,break_id,user_id,name,status&break_id=eq.${encodeURIComponent(breakId)}`;
        const allBreaksByIdResp = await fetch(allBreaksByIdUrl, {
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`
          }
        });
        const allBreaksById = await allBreaksByIdResp.json();
        console.log('[UPDATE_BREAK] ğŸ” å…±æœ‰ ' + (Array.isArray(allBreaksById) ? allBreaksById.length : 0) + ' å€‹åœ˜æ‹†æ“æœ‰ break_id=' + breakId);
        if (Array.isArray(allBreaksById) && allBreaksById.length > 0) {
          allBreaksById.forEach((b, i) => {
            console.log('[UPDATE_BREAK] ğŸ” [' + i + '] user_id=' + b.user_id + ', id=' + b.id + ', name=' + b.name + ', status=' + b.status);
          });
        }
        
        // âŒ ä¸å†å˜—è©¦å‚™ç”¨æ–¹æ¡ˆï¼ˆæœƒæ›´æ–°åˆ°éŒ¯èª¤çš„ç”¨æˆ¶ï¼‰
        // å‰ç«¯æ‡‰è©²ç¢ºä¿ userId è¢«æ­£ç¢ºå‚³é
        matchDetails.push({ breakId, nickname, matched: false, reason: 'ç”¨æˆ¶+break_id ç²¾ç¢ºåŒ¹é…å¤±æ•— - å‰ç«¯æ‡‰å‚³éæ­£ç¢ºçš„ userId' });
        continue;
      }
      
      // æ›´æ–°ç¬¬ä¸€ç­†åŒ¹é…çš„åœ˜æ‹†
      const breakRecord = breaks[0];
      const updateUrl = `${supabase.url}/rest/v1/breaks?id=eq.${breakRecord.id}`;
      
      const updateResp = await fetch(updateUrl, {
        method: 'PATCH',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          status: 'ä»˜æ¬¾ç¢ºèªä¸­'
        })
      });
      
      if (!updateResp.ok) {
        const errText = await updateResp.text();
        console.error('[UPDATE_BREAK] HTTP éŒ¯èª¤:', updateResp.status, errText);
        matchDetails.push({ breakId, nickname, matched: false, reason: 'HTTP ' + updateResp.status });
        continue;
      }
      
      updatedCount++;
      console.log('[UPDATE_BREAK] âœ… å·²æ›´æ–°:', breakId, nickname, 'åŸç‹€æ…‹:', breakRecord.status, 'æ–°ç‹€æ…‹: ä»˜æ¬¾ç¢ºèªä¸­');
      matchDetails.push({ breakId, nickname, matched: true, oldStatus: breakRecord.status });
    }
    
    console.log('[UPDATE_BREAK] å®Œæˆï¼æˆåŠŸæ›´æ–° ' + updatedCount + '/' + details.length + ' ç­†');
    
    return {
      success: true,
      message: 'å·²æ›´æ–° ' + updatedCount + ' ç­†åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾ç¢ºèªä¸­ã€',
      updatedCount,
      totalRequested: details.length,
      matchDetails
    };
  } catch (error) {
    console.error('[UPDATE_BREAK] éŒ¯èª¤:', error);
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + error.toString() };
  }
}

async function handleUpdateOrderStatusToFailed(body, supabase) {
  const { orderDetails, paymentType } = body;
  
  if (!orderDetails || orderDetails.length === 0) {
    return { success: false, message: 'ç¼ºå°‘è¨‚å–®æ˜ç´°' };
  }
  
  let updatedCount = 0;
  
  try {
    if (paymentType === 'order') {
      // æ›´æ–°è¨‚å–®ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€
      for (const detail of orderDetails) {
        const { id } = detail;
        
        if (!id) {
          console.warn('[UPDATE_ORDER_FAILED] âš ï¸ è¨‚å–®ç¼ºå°‘ ID');
          continue;
        }
        
        console.log('[UPDATE_ORDER_FAILED] æº–å‚™æ›´æ–°è¨‚å–® ' + id + ' ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€');
        
        // ç›´æ¥ç”¨ ID æ›´æ–°è¨‚å–®
        const updateUrl = `${supabase.url}/rest/v1/orders?id=eq.${id}`;
        const patchResp = await fetch(updateUrl, {
          method: 'PATCH',
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
          },
          body: JSON.stringify({
            status: 'ä»˜æ¬¾å¤±æ•—'
          })
        });
        
        if (patchResp.ok) {
          updatedCount++;
          console.log('[UPDATE_ORDER_FAILED] âœ… è¨‚å–® ' + id + ' å·²æ›´æ–°ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€');
        } else {
          console.error('[UPDATE_ORDER_FAILED] âŒ æ›´æ–°è¨‚å–® ' + id + ' å¤±æ•—: HTTP ' + patchResp.status);
        }
      }
    } else if (paymentType === 'break') {
      // æ›´æ–°åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€
      for (const detail of orderDetails) {
        const { nickname, phone, breakId, userId: detailUserId } = detail;
        
        if (!breakId) {
          console.warn('[UPDATE_BREAK_FAILED] âš ï¸ åœ˜æ‹†ç¼ºå°‘ breakId');
          continue;
        }
        
        console.log('[UPDATE_BREAK_FAILED] æº–å‚™æ›´æ–°åœ˜æ‹† ' + breakId + ' ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€ï¼Œæš±ç¨±:', nickname);
        console.log('[UPDATE_BREAK_FAILED] ğŸ”¥ detail å…§å®¹:', JSON.stringify(detail));
        
        // ğŸ”¥ å„ªå…ˆä½¿ç”¨ userId ç›´æ¥åŒ¹é…ï¼ˆæœ€å¯é çš„æ–¹æ³•ï¼‰
        let userId = detailUserId;
        
        if (!userId) {
          console.error('[UPDATE_BREAK_FAILED] âŒ userId ç‚ºç©ºï¼Œç„¡æ³•é€²è¡Œç²¾ç¢ºåŒ¹é…!');
          console.error('[UPDATE_BREAK_FAILED] detail:', JSON.stringify(detail));
          continue;
        }
        
        console.log('[UPDATE_BREAK_FAILED] ğŸ”¥ ä½¿ç”¨ userId é€²è¡Œç²¾ç¢ºåŒ¹é…: ' + userId);
        
        // ç›´æ¥ç”¨ userId + breakId é€²è¡Œç²¾ç¢ºæŸ¥è©¢
        const breaksUrl = `${supabase.url}/rest/v1/breaks?select=id,break_id,user_id,status&break_id=eq.${encodeURIComponent(breakId)}&user_id=eq.${encodeURIComponent(userId)}`;
        const breaksResp = await fetch(breaksUrl, {
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`
          }
        });
        const breaks = await breaksResp.json();
        
        console.log('[UPDATE_BREAK_FAILED] æŸ¥è©¢çµæœ:', Array.isArray(breaks) ? breaks.length + ' ç­†' : 'éé™£åˆ—æˆ–éŒ¯èª¤');
        
        let breakRecord = null;
        if (Array.isArray(breaks) && breaks.length > 0) {
          breakRecord = breaks[0];
          console.log('[UPDATE_BREAK_FAILED] âœ… ç²¾ç¢ºåŒ¹é…æ‰¾åˆ°åœ˜æ‹†:', breakRecord.id);
        } else {
          console.error('[UPDATE_BREAK_FAILED] âŒ ç”¨æˆ¶+break_id ç²¾ç¢ºåŒ¹é…å¤±æ•—:', { breakId, userId, nickname });
        }
        
        if (!breakRecord) {
          console.error('[UPDATE_BREAK_FAILED] âŒ æ‰¾ä¸åˆ°åœ˜æ‹† ' + breakId);
          continue;
        }
        
        // æ›´æ–°åœ˜æ‹†ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€
        const updateUrl = `${supabase.url}/rest/v1/breaks?id=eq.${breakRecord.id}`;
        const patchResp = await fetch(updateUrl, {
          method: 'PATCH',
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
          },
          body: JSON.stringify({
            status: 'ä»˜æ¬¾å¤±æ•—'
          })
        });
        
        if (patchResp.ok) {
          updatedCount++;
          console.log('[UPDATE_BREAK_FAILED] âœ… åœ˜æ‹† ' + breakId + ' å·²æ›´æ–°ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€');
        } else {
          console.error('[UPDATE_BREAK_FAILED] âŒ æ›´æ–°åœ˜æ‹† ' + breakId + ' å¤±æ•—: HTTP ' + patchResp.status);
        }
      }
    }
    
    console.log('[UPDATE_FAILED] å®Œæˆï¼æˆåŠŸæ›´æ–° ' + updatedCount + '/' + orderDetails.length + ' ç­†');
    
    return {
      success: true,
      message: 'å·²æ›´æ–° ' + updatedCount + ' ç­†' + (paymentType === 'order' ? 'è¨‚å–®' : 'åœ˜æ‹†') + 'ç‹€æ…‹ç‚ºã€Œä»˜æ¬¾å¤±æ•—ã€',
      updatedCount,
      totalRequested: orderDetails.length
    };
  } catch (error) {
    console.error('[UPDATE_FAILED] éŒ¯èª¤:', error);
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + error.toString() };
  }
}

async function handleVerifyData(body, supabase) {
  const results = {};
  
  try {
    console.log('[VERIFY] Starting data verification...');
    
    // 1. æª¢æŸ¥æ‰€æœ‰è³‡æ–™è¡¨ç­†æ•¸
    const tables = [
      'users',
      'product_catalog', 
      'orders',
      'break_records',
      'notifications',
      'psa_orders',
      'break_credits',
      'daily_fortunes'
    ];
    
    results.tableCounts = {};
    for (const table of tables) {
      const data = await supabase.query(table, {});
      results.tableCounts[table] = Array.isArray(data) ? data.length : 0;
      console.log('[VERIFY] ' + table + ': ' + results.tableCounts[table] + ' rows');
    }
    
    // 2. æª¢æŸ¥ users ç¯„ä¾‹
    const users = await supabase.query('users', {});
    if (Array.isArray(users) && users.length > 0) {
      results.usersSample = users.slice(0, 2).map(u => ({
        phone: u.phone,
        nickname: u.nickname,
        birthday: u.birthday,
        birthdayType: typeof u.birthday
      }));
      results.usersFields = Object.keys(users[0]);
    }
    
    // 3. æª¢æŸ¥ product_catalog ç¯„ä¾‹
    const products = await supabase.query('product_catalog', {});
    if (Array.isArray(products) && products.length > 0) {
      results.productsSample = products.slice(0, 2).map(p => ({
        item_name: p.item_name,
        category: p.category,
        is_box_preorder: p.is_box_preorder,
        is_box_type: typeof p.is_box_preorder,
        total_quantity: p.total_quantity,
        current_quantity: p.current_quantity,
        close_time: p.close_time
      }));
      results.productsFields = Object.keys(products[0]);
      
      // çµ±è¨ˆåˆ†é¡
      const categories = {};
      const boxCount = { true: 0, false: 0, other: 0 };
      products.forEach(p => {
        categories[p.category] = (categories[p.category] || 0) + 1;
        if (p.is_box_preorder === 'true') boxCount.true++;
        else if (p.is_box_preorder === 'false') boxCount.false++;
        else boxCount.other++;
      });
      results.productStats = { categories, boxCount };
    }
    
    // 4. æª¢æŸ¥ orders ç¯„ä¾‹
    const orders = await supabase.query('orders', {});
    if (Array.isArray(orders) && orders.length > 0) {
      results.ordersSample = orders.slice(0, 2).map(o => ({
        phone: o.phone,
        nickname: o.nickname,
        item_name: o.item_name,
        user_id: o.user_id,
        has_user_id: !!o.user_id,
        is_cleared: o.is_cleared,
        is_shipped: o.is_shipped,
        order_date: o.order_date
      }));
      results.ordersFields = Object.keys(orders[0]);
      
      // çµ±è¨ˆ user_id
      let hasUserId = 0;
      let noUserId = 0;
      orders.forEach(o => {
        if (o.user_id) hasUserId++;
        else noUserId++;
      });
      results.orderStats = { hasUserId, noUserId, total: orders.length };
    }
    
    // 5. æª¢æŸ¥ç‰¹å®šç”¨æˆ¶è¨‚å–®
    const phone = '0975313096';
    const userOrders = await supabase.query('orders', { eq: { user_id: users[0].id } });
    results.testUserOrders = {
      phone,
      count: Array.isArray(userOrders) ? userOrders.length : 0,
      sample: Array.isArray(userOrders) && userOrders.length > 0 ? userOrders.slice(0, 2).map(o => ({
        item_name: o.item_name,
        quantity: o.quantity,
        order_date: o.order_date
      })) : []
    };
    
    console.log('[VERIFY] Verification completed successfully');
    
    return {
      success: true,
      timestamp: new Date().toISOString(),
      results
    };
    
  } catch (error) {
    console.error('[VERIFY] Error:', error);
    return {
      success: false,
      error: error.message,
      partialResults: results
    };
  }
}

// ==================== Worker å…¥å£ (åªè™•ç† API) ====================

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type'
        }
      });
    }

    // ==================== ç¶ ç•Œå›èª¿è·¯ç”± ====================
    if (request.method === 'POST' && url.pathname === '/ecpay-callback') {
      try {
        const supabaseUrl = env.SUPABASE_URL || DEFAULT_SUPABASE_URL;
        const supabaseKey = env.SUPABASE_ANON_KEY || DEFAULT_SUPABASE_ANON_KEY;
        const supabase = new SupabaseClient(supabaseUrl, supabaseKey);
        
        let params = {};
        const contentType = request.headers.get('content-type') || '';
        
        console.log('[ECPay Callback] Content-Type:', contentType);
        
        // ç¶ ç•Œå›èª¿ç¸½æ˜¯ç”¨ form-urlencoded
        if (contentType.includes('application/x-www-form-urlencoded')) {
          const text = await request.text();
          console.log('[ECPay Callback] æ”¶åˆ°åŸå§‹æ–‡æœ¬:', text.substring(0, 100));
          
          const formData = new URLSearchParams(text);
          for (const [key, value] of formData.entries()) {
            params[key] = value;
          }
          console.log('[ECPay Callback] è§£æå¾Œåƒæ•¸æ•¸é‡:', Object.keys(params).length);
        } else if (contentType.includes('application/json')) {
          // å‚™ç”¨ï¼šå¦‚æœæ˜¯ JSON æ ¼å¼
          params = await request.json();
        } else {
          // å¦‚æœæ²’æœ‰æŒ‡å®š Content-Typeï¼Œè©¦è‘—ç•¶æˆ form è™•ç†
          const text = await request.text();
          if (text) {
            const formData = new URLSearchParams(text);
            for (const [key, value] of formData.entries()) {
              params[key] = value;
            }
          }
        }
        
        console.log('[ECPay Callback] é–‹å§‹è™•ç†å›èª¿');
        
        const result = await handleEcpayCallback(params, supabase);
        
        return new Response(JSON.stringify(result), {
          headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
        });
      } catch (error) {
        console.error('[ECPay Callback] éŒ¯èª¤:', error.message || error);
        return new Response(JSON.stringify({ success: false, message: error.message }), {
          status: 200,  // è¿”å› 200 è®“ç¶ ç•ŒçŸ¥é“æˆ‘å€‘æ”¶åˆ°äº†
          headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
        });
      }
    }

    if (request.method === 'POST' && url.pathname === '/api') {
      return handleAPI(request, env);
    }

    return new Response('Not Found', { status: 404 });
  }
};

// ===== ğŸŒŸ å¾Œå°ç®¡ç† API å‡½æ•¸ =====

async function handleAdminLogin(body, supabase) {
  const { password } = body;
  const ADMIN_PASSWORD = 'ning123'; // ğŸ”‘ ç®¡ç†å“¡å¯†ç¢¼ï¼ˆæ‡‰æ”¾åœ¨ç’°å¢ƒè®Šæ•¸ï¼‰
  
  if (password === ADMIN_PASSWORD) {
    return { success: true, message: 'ç™»å…¥æˆåŠŸ', token: 'admin_token_' + Date.now() };
  } else {
    return { success: false, message: 'å¯†ç¢¼éŒ¯èª¤' };
  }
}

async function handleGetNotifications(body, supabase) {
  const { limit = 50, offset = 0 } = body;
  
  const headers = {
    'apikey': supabase.apiKey,
    'Authorization': `Bearer ${supabase.apiKey}`,
    'Content-Type': 'application/json'
  };
  
  // ç›´æ¥æŸ¥è©¢ notifications è¡¨ä¸¦é—œè¯ users è¡¨å–å¾—æš±ç¨±
  const queryUrl = `${supabase.url}/rest/v1/notifications?select=*,users:user_id(nickname,phone)&order=sent_at.desc&limit=${limit}&offset=${offset}`;
  
  const response = await fetch(queryUrl, { headers });
  const notifications = await response.json();
  
  if (!Array.isArray(notifications)) {
    return { success: true, notifications: [], count: 0 };
  }
  
  // å°æ¯å€‹ notification æŸ¥è©¢è©²ç­†é€šçŸ¥å‹¾é¸çš„è¨‚å–®
  const enrichedNotifications = await Promise.all(
    notifications.map(async (notif) => {
      try {
        const content = JSON.parse(notif.content || '{}');
        
        let relatedOrders = [];
        let relatedBreaks = [];
        
        // ğŸŒŸ æ ¹æ“š paymentType æŸ¥è©¢ç›¸é—œè³‡æ–™
        if (content.paymentType === 'break') {
          // åœ˜æ‹†é€šçŸ¥ - æŸ¥è©¢åœ˜æ‹†è³‡æ–™
          if (content.breakIds && typeof content.breakIds === 'string') {
            const breakIds = content.breakIds
              .split('||')
              .filter(id => id && id.trim())
              .map(id => id.trim());
            
            console.log('[getNotifications] é€šçŸ¥ ID:', notif.id, 'æ‰¾åˆ°åœ˜æ‹† ID:', breakIds);
            
            if (breakIds.length > 0) {
              try {
                // ğŸ”¥ ä½¿ç”¨ break_id + user_id æŸ¥è©¢åœ˜æ‹†ï¼ˆé‡é»ï¼šåŠ ä¸Šuser_idéæ¿¾ä»¥å€åˆ†ä¸åŒç”¨æˆ¶çš„åŒååœ˜æ‹†ï¼ï¼‰
                const breakQueryUrl = `${supabase.url}/rest/v1/breaks?break_id=in.(${breakIds.map(id => `"${encodeURIComponent(id)}"`).join(',')})&user_id=eq.${notif.user_id}`;
                
                const breaksResponse = await fetch(breakQueryUrl, { headers });
                relatedBreaks = await breaksResponse.json();
                
                console.log('[getNotifications] åœ˜æ‹†æŸ¥è©¢çµæœ:', relatedBreaks, '(user_id:', notif.user_id, ')');
                
                if (!Array.isArray(relatedBreaks)) {
                  relatedBreaks = [];
                }
              } catch (breakErr) {
                console.error('[getNotifications] æŸ¥è©¢åœ˜æ‹†ç•°å¸¸:', breakErr);
                relatedBreaks = [];
              }
            }
          }
        } else {
          // è¨‚å–®é€šçŸ¥ - æŸ¥è©¢è¨‚å–®è³‡æ–™
          if (content.orderIds && typeof content.orderIds === 'string') {
            // ç”¨ || åˆ†éš”ç¬¦
            const selectedOrderIds = content.orderIds
              .split('||')
              .filter(id => id && id.trim())
              .map(id => id.trim());
            
            console.log('[getNotifications] é€šçŸ¥ ID:', notif.id, 'æ‰¾åˆ°è¨‚å–® ID:', selectedOrderIds);
            
            if (selectedOrderIds && selectedOrderIds.length > 0) {
              try {
                // æŸ¥è©¢é€™äº›ç‰¹å®šçš„è¨‚å–®
                const orderIdsStr = selectedOrderIds.join(',');
                const ordersUrl = `${supabase.url}/rest/v1/orders?id=in.(${orderIdsStr})`;
                
                console.log('[getNotifications] æŸ¥è©¢ URL:', ordersUrl);
                
                const ordersResponse = await fetch(ordersUrl, { headers });
                relatedOrders = await ordersResponse.json();
                
                console.log('[getNotifications] è¨‚å–®æŸ¥è©¢çµæœ:', relatedOrders);
                
                if (!Array.isArray(relatedOrders)) {
                  relatedOrders = [];
                }
              } catch (orderErr) {
                console.error('[getNotifications] æŸ¥è©¢è¨‚å–®ç•°å¸¸:', orderErr);
                relatedOrders = [];
              }
            }
          }
        }
        
        return {
          ...notif,
          nickname: notif.users?.nickname || 'æœªçŸ¥',
          phone: notif.users?.phone || '',
          relatedOrders: relatedOrders,
          relatedBreaks: relatedBreaks,
          contentParsed: content
        };
      } catch (err) {
        console.error('Error enriching notification:', err);
        return { 
          ...notif, 
          nickname: 'æœªçŸ¥', 
          phone: '', 
          relatedOrders: [],
          contentParsed: {}
        };
      }
    })
  );
  
  return { 
    success: true, 
    notifications: enrichedNotifications,
    count: enrichedNotifications.length
  };
}

async function handleUpdateNotification(body, supabase) {
  const { id, status } = body;
  
  const updateUrl = `${supabase.url}/rest/v1/notifications?id=eq.${id}`;
  
  const response = await fetch(updateUrl, {
    method: 'PATCH',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ status: status })
  });
  
  let result = [];
  const responseText = await response.text();
  
  // åªæœ‰ç•¶å›æ‡‰ä¸ç‚ºç©ºæ™‚æ‰è§£æ JSON
  if (responseText && responseText.trim()) {
    try {
      result = JSON.parse(responseText);
    } catch (parseErr) {
      console.error('[updateNotification] JSON è§£æå¤±æ•—:', parseErr);
      result = [];
    }
  }
  
  if (response.ok) {
    return { success: true, message: 'æ›´æ–°æˆåŠŸ' };
  } else {
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + (result.message || result.details || 'æœªçŸ¥éŒ¯èª¤') };
  }
}

async function handleDeleteNotification(body, supabase) {
  const { id } = body;
  
  const deleteUrl = `${supabase.url}/rest/v1/notifications?id=eq.${id}`;
  
  const response = await fetch(deleteUrl, {
    method: 'DELETE',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  if (response.ok) {
    return { success: true, message: 'åˆªé™¤æˆåŠŸ' };
  } else {
    return { success: false, message: 'åˆªé™¤å¤±æ•—' };
  }
}

async function handleSearchOrders(body, supabase) {
  const { phone, nickname, item, limit = 50, offset = 0 } = body;
  
  console.log('[handleSearchOrders] æœå°‹åƒæ•¸:', { phone, nickname, item });
  
  try {
    // å…ˆæŸ¥è©¢æ‰€æœ‰è¨‚å–®
    let queryUrl = `${supabase.url}/rest/v1/orders?select=*&order=timestamp.desc&limit=1000`;
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    };
    
    const response = await fetch(queryUrl, { headers });
    const allOrders = await response.json();
    
    console.log('[handleSearchOrders] æ‰¾åˆ° ' + (Array.isArray(allOrders) ? allOrders.length : 0) + ' ç­†è¨‚å–®');
    
    if (!Array.isArray(allOrders)) {
      return { success: true, orders: [], count: 0 };
    }
    
    // å¦‚æœéœ€è¦æŒ‰ phone æˆ– nickname æœå°‹ï¼Œéœ€è¦ JOIN ç”¨æˆ¶è³‡æ–™
    let filtered = allOrders;
    
    if (phone || nickname) {
      // æŸ¥è©¢æ‰€æœ‰ç”¨æˆ¶
      const userQueryUrl = `${supabase.url}/rest/v1/users?select=*&limit=1000`;
      const userResponse = await fetch(userQueryUrl, { headers });
      const allUsers = await userResponse.json();
      const userMap = new Map();
      
      if (Array.isArray(allUsers)) {
        allUsers.forEach(u => {
          userMap.set(u.id, u);
        });
      }
      
      console.log('[handleSearchOrders] è¼‰å…¥ ' + userMap.size + ' å€‹ç”¨æˆ¶è³‡æ–™');
      
      // ç”¨æˆ¶ç«¯ JOINï¼šç‚ºè¨‚å–®æ·»åŠ ç”¨æˆ¶ä¿¡æ¯
      filtered = filtered.map(o => ({
        ...o,
        nickname: userMap.get(o.user_id)?.nickname || o.nickname || '',
        phone: userMap.get(o.user_id)?.phone || o.phone || ''
      }));
      
      // æŒ‰ phone æˆ– nickname éæ¿¾
      if (phone) {
        filtered = filtered.filter(o => o.phone && o.phone.toString().includes(phone.toString()));
      }
      
      if (nickname) {
        filtered = filtered.filter(o => o.nickname && o.nickname.toLowerCase().includes(nickname.toLowerCase()));
      }
    }
    
    // æŒ‰ item éæ¿¾
    if (item) {
      filtered = filtered.filter(o => o.item && o.item.toLowerCase().includes(item.toLowerCase()));
    }
    
    console.log('[handleSearchOrders] éæ¿¾å¾Œæ‰¾åˆ° ' + filtered.length + ' ç­†è¨‚å–®');
    
    return { 
      success: true, 
      orders: filtered.slice(offset, offset + limit),
      count: filtered.length
    };
  } catch (error) {
    console.error('[handleSearchOrders] éŒ¯èª¤:', error);
    return { success: false, message: 'æœå°‹å¤±æ•—: ' + error.message };
  }
}

async function handleSearchUsers(body, supabase) {
  const { phone, nickname, limit = 50, offset = 0 } = body;
  
  console.log('[handleSearchUsers] æœå°‹åƒæ•¸:', { phone, nickname });
  
  try {
    // æŸ¥è©¢æ‰€æœ‰ç”¨æˆ¶
    const queryUrl = `${supabase.url}/rest/v1/users?select=*&limit=1000`;
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    };
    
    const response = await fetch(queryUrl, { headers });
    const allUsers = await response.json();
    
    console.log('[handleSearchUsers] æ‰¾åˆ° ' + (Array.isArray(allUsers) ? allUsers.length : 0) + ' å€‹ç”¨æˆ¶');
    
    if (!Array.isArray(allUsers)) {
      return { success: true, users: [], count: 0 };
    }
    
    // ç”¨æˆ¶ç«¯éæ¿¾
    let filtered = allUsers;
    
    if (phone) {
      filtered = filtered.filter(u => u.phone && u.phone.toString().includes(phone.toString()));
    }
    
    if (nickname) {
      filtered = filtered.filter(u => u.nickname && u.nickname.toLowerCase().includes(nickname.toLowerCase()));
    }
    
    console.log('[handleSearchUsers] éæ¿¾å¾Œæ‰¾åˆ° ' + filtered.length + ' å€‹ç”¨æˆ¶');
    
    // å»é‡ï¼ˆä»¥ id ç‚ºåŸºæº–ï¼‰
    const uniqueUsers = Array.from(new Map(filtered.map(u => [u.id, u])).values());
    
    return { 
      success: true, 
      users: uniqueUsers.slice(offset, offset + limit),
      count: uniqueUsers.length
    };
  } catch (error) {
    console.error('[handleSearchUsers] éŒ¯èª¤:', error);
    return { success: false, message: 'æœå°‹å¤±æ•—: ' + error.message };
  }
}

async function handleUpdateOrder(body, supabase) {
  try {
    const { id, status, balance, balance_amount, notes, manual_price } = body;
    
    const updateData = {};
    if (status) updateData.status = status;
    // åŒæ™‚æ”¯æŒ balance å’Œ balance_amountï¼Œå„ªå…ˆä½¿ç”¨å‚³å…¥çš„ä»»ä¸€å€‹
    if (balance !== undefined) updateData.balance_amount = balance;
    if (balance_amount !== undefined) updateData.balance_amount = balance_amount;
    if (notes) updateData.notes = notes;
    if (manual_price !== undefined) updateData.remark = manual_price; // ä½¿ç”¨ remark æ¬„ä½å­˜å„²æ‰‹å‹•èª¿åƒ¹æ¨™è¨˜
    updateData.updated_at = new Date().toISOString();
    
    console.log('[handleUpdateOrder] æ›´æ–°è¨‚å–®:', { id, ...updateData });
    
    const updateUrl = `${supabase.url}/rest/v1/orders?id=eq.${id}`;
    
    const response = await fetch(updateUrl, {
      method: 'PATCH',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'  // è®“ Supabase è¿”å›æ›´æ–°å¾Œçš„è³‡æ–™
      },
      body: JSON.stringify(updateData)
    });
    
    console.log('[handleUpdateOrder] HTTP ç‹€æ…‹:', response.status);
    
    let result = [];
    const responseText = await response.text();
    console.log('[handleUpdateOrder] åŸå§‹å›æ‡‰:', responseText);
    
    // åªæœ‰ç•¶å›æ‡‰ä¸ç‚ºç©ºæ™‚æ‰è§£æ JSON
    if (responseText && responseText.trim()) {
      try {
        result = JSON.parse(responseText);
      } catch (parseErr) {
        console.error('[handleUpdateOrder] JSON è§£æå¤±æ•—:', parseErr, 'å›æ‡‰å…§å®¹:', responseText);
        result = [];
      }
    }
    
    if (response.ok) {
      console.log('[handleUpdateOrder] âœ… æ›´æ–°æˆåŠŸï¼Œè¿”å›:', result);
      // è¿”å›æ›´æ–°å¾Œçš„è¨‚å–®ï¼ˆSupabase åœ¨ Prefer: return=representation æ™‚æœƒè¿”å›é™£åˆ—ï¼‰
      const updatedOrder = Array.isArray(result) && result.length > 0 ? result[0] : result;
      return { 
        success: true, 
        message: 'è¨‚å–®æ›´æ–°æˆåŠŸ',
        order: updatedOrder 
      };
    } else {
      console.error('[handleUpdateOrder] âŒ æ›´æ–°å¤±æ•—:', result);
      return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + (result.message || result.details || 'æœªçŸ¥éŒ¯èª¤') };
    }
  } catch (error) {
    console.error('[handleUpdateOrder] ç•°å¸¸:', error);
    return { success: false, message: 'æ›´æ–°ç•°å¸¸: ' + error.message };
  }
}

async function handleGetUsers(body, supabase) {
  const { limit = 100, offset = 0 } = body;
  
  try {
    // ç›´æ¥æŸ¥è©¢ç”¨æˆ¶è¡¨
    const queryUrl = `${supabase.url}/rest/v1/users?select=*&limit=${limit}&offset=${offset}&order=created_at.desc`;
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    };
    
    const response = await fetch(queryUrl, { headers });
    const users = await response.json();
    
    if (!Array.isArray(users)) {
      return { success: true, users: [], count: 0 };
    }
    
    // å»é‡ï¼ˆä»¥ id ç‚ºåŸºæº–ï¼‰
    const uniqueUsers = Array.from(new Map(users.map(u => [u.id, u])).values());
    
    return { 
      success: true, 
      users: uniqueUsers,
      count: uniqueUsers.length
    };
  } catch (error) {
    console.error('[handleGetUsers] éŒ¯èª¤:', error);
    return { success: false, message: 'è¼‰å…¥å¤±æ•—: ' + error.message };
  }
}

async function handleUpdateUser(body, supabase) {
  const { phone, nickname, email, address, real_name, cvs_store_name, cvs_store_id } = body;
  
  const updateData = {};
  if (nickname !== undefined) updateData.nickname = nickname;
  if (email !== undefined) updateData.email = email;
  if (address !== undefined) updateData.address = address;
  if (real_name !== undefined) updateData.real_name = real_name;
  if (cvs_store_name !== undefined) updateData.cvs_store_name = cvs_store_name;
  if (cvs_store_id !== undefined) updateData.cvs_store_id = cvs_store_id;
  
  const updateUrl = `${supabase.url}/rest/v1/users?phone=eq.${phone}`;
  
  const response = await fetch(updateUrl, {
    method: 'PATCH',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=minimal'
    },
    body: JSON.stringify(updateData)
  });
  
  if (response.ok) {
    return { success: true, message: 'ç”¨æˆ¶æ›´æ–°æˆåŠŸ' };
  } else {
    const text = await response.text();
    let errorMsg = 'æ›´æ–°å¤±æ•—';
    try {
      const result = JSON.parse(text);
      errorMsg = 'æ›´æ–°å¤±æ•—: ' + (result.message || result.details || text);
    } catch (e) {
      errorMsg = 'æ›´æ–°å¤±æ•—: ' + text;
    }
    return { success: false, message: errorMsg };
  }
}

async function handleAddProduct(body, supabase) {
  const { 
    item_name, card_no, price, threshold_price, discount_threshold, min_group_quantity,
    is_available, is_box_preorder, can_direct_order, stock_status, category,
    can_draw_sp, can_draw_signature, can_draw_relic, can_draw_auto_relic,
    image_url_1, image_url_2, image_url_3, image_url_4, remaining_stock, scheduled_delist_time, description 
  } = body;
  
  const productData = {
    item_name: item_name,
    card_no: card_no || '',
    price: Number(price),
    threshold_price: Number(threshold_price) || null,
    discount_threshold: Number(discount_threshold) || null,
    min_group_quantity: Number(min_group_quantity) || null,
    is_available: is_available === true || is_available === 'true' || is_available === 'Y',
    is_box_preorder: is_box_preorder === true || is_box_preorder === 'true',
    can_direct_order: can_direct_order === true || can_direct_order === 'true',
    stock_status: stock_status || 'V',
    category: category || 'æ£’çƒ',
    can_draw_sp: can_draw_sp === true || can_draw_sp === 'true',
    can_draw_signature: can_draw_signature === true || can_draw_signature === 'true',
    can_draw_relic: can_draw_relic === true || can_draw_relic === 'true',
    can_draw_auto_relic: can_draw_auto_relic === true || can_draw_auto_relic === 'true',
    image_url_1: image_url_1 || '',
    image_url_2: image_url_2 || '',
    image_url_3: image_url_3 || '',
    image_url_4: image_url_4 || '',
    remaining_stock: remaining_stock ? Number(remaining_stock) : null,
    scheduled_delist_time: scheduled_delist_time || null,
    description: description || '',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
  
  const insertUrl = `${supabase.url}/rest/v1/product_catalog`;
  
  const response = await fetch(insertUrl, {
    method: 'POST',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    },
    body: JSON.stringify(productData)
  });
  
  if (response.ok) {
    const result = await response.json();
    return { success: true, message: 'å•†å“æ–°å¢æˆåŠŸ', product: result[0] };
  } else {
    const errorText = await response.text();
    return { success: false, message: 'æ–°å¢å¤±æ•—: ' + errorText };
  }
}

// ğŸŒŸ å•†å“ç®¡ç† API
async function handleGetAllProducts(body, supabase) {
  const { item_name, card_no, is_available } = body;
  
  let url = `${supabase.url}/rest/v1/product_catalog?select=*&order=created_at.desc`;
  
  // ç¯©é¸æ¢ä»¶
  if (item_name && item_name.trim() !== '') {
    url += `&item_name=ilike.*${item_name}*`;
  }
  if (card_no && card_no.trim() !== '') {
    url += `&card_no=ilike.*${card_no}*`;
  }
  if (is_available !== undefined && is_available !== null && is_available !== '') {
    const availValue = is_available === true || is_available === 'true' || is_available === 'Y';
    url += `&is_available=eq.${availValue}`;
  }
  
  const response = await fetch(url, {
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  if (response.ok) {
    const products = await response.json();
    return { success: true, products };
  } else {
    const errorText = await response.text();
    return { success: false, message: 'æŸ¥è©¢å¤±æ•—: ' + errorText };
  }
}

async function handleUpdateProduct(body, supabase) {
  const { id } = body;
  
  if (!id) {
    return { success: false, message: 'ç¼ºå°‘å•†å“ ID' };
  }
  
  // åªæå–éœ€è¦æ›´æ–°çš„æ¬„ä½
  const updateData = {};
  const allowedFields = [
    'item_name', 'card_no', 'price', 'threshold_price', 'discount_threshold', 'min_group_quantity',
    'is_available', 'is_box_preorder', 'can_direct_order', 'stock_status', 'category',
    'can_draw_sp', 'can_draw_signature', 'can_draw_relic', 'can_draw_auto_relic',
    'image_url_1', 'image_url_2', 'image_url_3', 'image_url_4', 'remaining_stock',
    'scheduled_delist_time', 'description'
  ];
  
  allowedFields.forEach(field => {
    if (body[field] !== undefined) {
      updateData[field] = body[field];
    }
  });
  
  // è™•ç†å¸ƒæ—å€¼
  if (updateData.is_available !== undefined) {
    updateData.is_available = updateData.is_available === true || updateData.is_available === 'true' || updateData.is_available === 'Y';
  }
  if (updateData.is_box_preorder !== undefined) {
    updateData.is_box_preorder = updateData.is_box_preorder === true || updateData.is_box_preorder === 'true';
  }
  if (updateData.can_direct_order !== undefined) {
    updateData.can_direct_order = updateData.can_direct_order === true || updateData.can_direct_order === 'true';
  }
  // ä¿®æ­£ï¼šæ­£ç¢ºè™•ç† false å€¼
  if (updateData.can_draw_sp !== undefined) {
    updateData.can_draw_sp = updateData.can_draw_sp === true || updateData.can_draw_sp === 'true' || updateData.can_draw_sp === 1;
  }
  if (updateData.can_draw_signature !== undefined) {
    updateData.can_draw_signature = updateData.can_draw_signature === true || updateData.can_draw_signature === 'true' || updateData.can_draw_signature === 1;
  }
  if (updateData.can_draw_relic !== undefined) {
    updateData.can_draw_relic = updateData.can_draw_relic === true || updateData.can_draw_relic === 'true' || updateData.can_draw_relic === 1;
  }
  if (updateData.can_draw_auto_relic !== undefined) {
    updateData.can_draw_auto_relic = updateData.can_draw_auto_relic === true || updateData.can_draw_auto_relic === 'true' || updateData.can_draw_auto_relic === 1;
  }
  
  // è™•ç†æ•¸å€¼
  if (updateData.price !== undefined) updateData.price = Number(updateData.price);
  if (updateData.threshold_price !== undefined) updateData.threshold_price = Number(updateData.threshold_price) || null;
  if (updateData.discount_threshold !== undefined) updateData.discount_threshold = Number(updateData.discount_threshold) || null;
  if (updateData.min_group_quantity !== undefined) updateData.min_group_quantity = Number(updateData.min_group_quantity) || null;
  if (updateData.remaining_stock !== undefined) updateData.remaining_stock = Number(updateData.remaining_stock) || null;
  
  updateData.updated_at = new Date().toISOString();
  
  const updateUrl = `${supabase.url}/rest/v1/product_catalog?id=eq.${id}`;
  
  const response = await fetch(updateUrl, {
    method: 'PATCH',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(updateData)
  });
  
  if (response.ok) {
    // å¦‚æœæ›´æ–°äº†å•†å“åˆ°è²¨ç‹€æ…‹ç‚º 'V'ï¼Œé€£å‹•æ›´æ–°ç›¸é—œè¨‚å–®çš„åˆ°è²¨ç‹€æ…‹
    if (updateData.stock_status === 'V') {
      try {
        // å…ˆæŸ¥è©¢å•†å“çš„ item_name å’Œ card_no
        const productUrl = `${supabase.url}/rest/v1/product_catalog?id=eq.${id}&select=item_name,card_no`;
        const productRes = await fetch(productUrl, {
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`
          }
        });
        
        if (productRes.ok) {
          const products = await productRes.json();
          if (products && products.length > 0) {
            const product = products[0];
            const itemName = product.item_name;
            const cardNo = product.card_no;
            
            console.log('[UPDATE_PRODUCT] Cascading arrival status to orders:', { itemName, cardNo });
            
            // æ›´æ–°è¨‚å–®çš„åˆ°è²¨ç‹€æ…‹
            const ordersUpdateUrl = `${supabase.url}/rest/v1/orders?item=eq.${encodeURIComponent(itemName)}&card_no=eq.${encodeURIComponent(cardNo)}`;
            const ordersUpdateRes = await fetch(ordersUpdateUrl, {
              method: 'PATCH',
              headers: {
                'apikey': supabase.apiKey,
                'Authorization': `Bearer ${supabase.apiKey}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ arrival_status: 'V' })
            });
            
            if (ordersUpdateRes.ok) {
              console.log('[UPDATE_PRODUCT] Orders arrival status updated successfully');
            } else {
              const errorText = await ordersUpdateRes.text();
              console.error('[UPDATE_PRODUCT] Failed to update orders arrival status:', errorText);
            }
          }
        }
      } catch (cascadeError) {
        console.error('[UPDATE_PRODUCT] Cascade update error:', cascadeError);
        // ä¸é˜»æ–·å•†å“æ›´æ–°æˆåŠŸçš„è¿”å›ï¼Œåªè¨˜éŒ„éŒ¯èª¤
      }
    }
    
    return { success: true, message: 'å•†å“æ›´æ–°æˆåŠŸ' };
  } else {
    const errorText = await response.text();
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + errorText };
  }
}

async function handleDeleteProduct(body, supabase) {
  const { id } = body;
  
  if (!id) {
    return { success: false, message: 'ç¼ºå°‘å•†å“ ID' };
  }
  
  const deleteUrl = `${supabase.url}/rest/v1/product_catalog?id=eq.${id}`;
  
  const response = await fetch(deleteUrl, {
    method: 'DELETE',
    headers: {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    }
  });
  
  if (response.ok) {
    return { success: true, message: 'å•†å“åˆªé™¤æˆåŠŸ' };
  } else {
    const errorText = await response.text();
    return { success: false, message: 'åˆªé™¤å¤±æ•—: ' + errorText };
  }
}

async function handleCleanupDuplicateUsers(body, supabase) {
  const { adminPassword } = body;
  
  // é©—è­‰å¯†ç¢¼
  if (adminPassword !== 'ning123') {
    return { success: false, message: 'å¯†ç¢¼éŒ¯èª¤' };
  }
  
  try {
    console.log('[cleanupDuplicateUsers] é–‹å§‹æ¸…ç† password ç‚º NULL çš„é‡è¤‡ç”¨æˆ¶...');
    
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    };
    
    // ç¬¬ä¸€æ­¥ï¼šæŸ¥è©¢æ‰€æœ‰ password ç‚º NULL çš„ç”¨æˆ¶
    const queryUrl = `${supabase.url}/rest/v1/users?select=id,phone,password&password=is.null&limit=1000`;
    const response = await fetch(queryUrl, { headers });
    const nullPasswordUsers = await response.json();
    
    console.log('[cleanupDuplicateUsers] æ‰¾åˆ° ' + (Array.isArray(nullPasswordUsers) ? nullPasswordUsers.length : 0) + ' å€‹ password ç‚º NULL çš„ç”¨æˆ¶');
    
    if (!Array.isArray(nullPasswordUsers) || nullPasswordUsers.length === 0) {
      return { success: true, message: 'æ²’æœ‰éœ€è¦æ¸…ç†çš„ç”¨æˆ¶', deletedUsers: 0, deletedShipments: 0 };
    }
    
    const idsToDelete = nullPasswordUsers.map(u => u.id);
    
    // ç¬¬äºŒæ­¥ï¼šä¸€æ¬¡æ€§æŸ¥è©¢æ‰€æœ‰ç›¸é—œçš„è¨˜éŒ„
    const inClause = idsToDelete.join(',');
    
    // åˆªé™¤ shipments è¨˜éŒ„
    console.log('[cleanupDuplicateUsers] åˆªé™¤ç›¸é—œ shipments è¨˜éŒ„...');
    const deleteShipmentsUrl = `${supabase.url}/rest/v1/shipments?user_id=in.(${inClause})`;
    const deleteShipmentsResponse = await fetch(deleteShipmentsUrl, {
      method: 'DELETE',
      headers
    });
    
    let deletedShipments = 0;
    if (deleteShipmentsResponse.ok) {
      const contentRange = deleteShipmentsResponse.headers.get('content-range');
      deletedShipments = contentRange ? parseInt(contentRange.split('/')[1]) : 0;
      console.log('[cleanupDuplicateUsers] å·²åˆªé™¤ ' + deletedShipments + ' å€‹ shipments è¨˜éŒ„');
    } else {
      const errorText = await deleteShipmentsResponse.text();
      console.error('[cleanupDuplicateUsers] åˆªé™¤ shipments å¤±æ•—:', errorText);
      throw new Error('åˆªé™¤å‡ºè²¨è¨˜éŒ„å¤±æ•—: ' + errorText);
    }
    
    // åˆªé™¤ lottery è¨˜éŒ„
    console.log('[cleanupDuplicateUsers] åˆªé™¤ç›¸é—œ lottery è¨˜éŒ„...');
    const deleteLotteryUrl = `${supabase.url}/rest/v1/lottery?user_id=in.(${inClause})`;
    const deleteLotteryResponse = await fetch(deleteLotteryUrl, {
      method: 'DELETE',
      headers
    });
    
    let deletedLottery = 0;
    if (deleteLotteryResponse.ok) {
      const contentRange = deleteLotteryResponse.headers.get('content-range');
      deletedLottery = contentRange ? parseInt(contentRange.split('/')[1]) : 0;
      console.log('[cleanupDuplicateUsers] å·²åˆªé™¤ ' + deletedLottery + ' å€‹ lottery è¨˜éŒ„');
    } else {
      const errorText = await deleteLotteryResponse.text();
      console.warn('[cleanupDuplicateUsers] åˆªé™¤ lottery è¨˜éŒ„å¤±æ•—ï¼ˆå¯èƒ½ä¸å­˜åœ¨æ­¤è¡¨ï¼‰:', errorText);
    }
    
    // åˆªé™¤ notifications è¨˜éŒ„
    console.log('[cleanupDuplicateUsers] åˆªé™¤ç›¸é—œ notifications è¨˜éŒ„...');
    const deleteNotificationsUrl = `${supabase.url}/rest/v1/notifications?user_id=in.(${inClause})`;
    const deleteNotificationsResponse = await fetch(deleteNotificationsUrl, {
      method: 'DELETE',
      headers
    });
    
    let deletedNotifications = 0;
    if (deleteNotificationsResponse.ok) {
      const contentRange = deleteNotificationsResponse.headers.get('content-range');
      deletedNotifications = contentRange ? parseInt(contentRange.split('/')[1]) : 0;
      console.log('[cleanupDuplicateUsers] å·²åˆªé™¤ ' + deletedNotifications + ' å€‹ notifications è¨˜éŒ„');
    } else {
      const errorText = await deleteNotificationsResponse.text();
      console.warn('[cleanupDuplicateUsers] åˆªé™¤ notifications è¨˜éŒ„å¤±æ•—:', errorText);
    }
    
    // ç¬¬ä¸‰æ­¥ï¼šåˆªé™¤æ‰€æœ‰ password ç‚º NULL çš„ç”¨æˆ¶ï¼ˆä¸€æ¬¡æ€§ï¼‰
    console.log('[cleanupDuplicateUsers] åˆªé™¤ç”¨æˆ¶...');
    const deleteUsersUrl = `${supabase.url}/rest/v1/users?id=in.(${inClause})`;
    const deleteUsersResponse = await fetch(deleteUsersUrl, {
      method: 'DELETE',
      headers
    });
    
    if (!deleteUsersResponse.ok) {
      const errorText = await deleteUsersResponse.text();
      console.error('[cleanupDuplicateUsers] åˆªé™¤ç”¨æˆ¶å¤±æ•—:', errorText);
      throw new Error('åˆªé™¤ç”¨æˆ¶å¤±æ•—: ' + errorText);
    }
    
    const deletedUsers = idsToDelete.length;
    console.log('[cleanupDuplicateUsers] æ¸…ç†å®Œæˆï¼Œå…±åˆªé™¤ ' + deletedUsers + ' å€‹ç”¨æˆ¶å’Œ ' + deletedShipments + ' å€‹å‡ºè²¨è¨˜éŒ„');
    
    return { 
      success: true, 
      message: 'æ¸…ç†å®Œæˆï¼å·²åˆªé™¤ ' + deletedUsers + ' å€‹é‡è¤‡ç”¨æˆ¶å’Œ ' + deletedShipments + ' å€‹ç›¸é—œå‡ºè²¨è¨˜éŒ„',
      deletedUsers: deletedUsers,
      deletedShipments: deletedShipments
    };
  } catch (error) {
    console.error('[cleanupDuplicateUsers] éŒ¯èª¤:', error);
    return { success: false, message: 'æ¸…ç†å¤±æ•—: ' + error.message };
  }
}

// ==================== åœ˜æ‹†ç®¡ç† API ====================

async function handleGetAllBreaks(body, supabase) {
  try {
    console.log('[getAllBreaks] æŸ¥è©¢æ‰€æœ‰åœ˜æ‹†ï¼ˆå«ç”¨æˆ¶ä¿¡æ¯ï¼‰');
    
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`,
      'Content-Type': 'application/json'
    };
    
    // ğŸ”‘ é—œè¯ users è¡¨ä¾†ç²å–è¨‚è³¼äººä¿¡æ¯
    const queryUrl = `${supabase.url}/rest/v1/breaks?select=*,users:user_id(id,nickname,phone,email)&order=created_at.desc`;
    
    const response = await fetch(queryUrl, { headers });
    const breaksData = await response.json();
    
    if (!Array.isArray(breaksData)) {
      console.error('[getAllBreaks] æŸ¥è©¢çµæœéé™£åˆ—:', breaksData);
      return { success: false, message: 'æŸ¥è©¢å¤±æ•—' };
    }
    
    console.log('[getAllBreaks] å…±æ‰¾åˆ° ' + breaksData.length + ' ç­†åœ˜æ‹†');
    
    // æ ¼å¼åŒ–æ•¸æ“šï¼Œå°‡ user_id æ›¿æ›ç‚ºç”¨æˆ¶ä¿¡æ¯
    const formattedBreaks = breaksData.map(b => ({
      ...b,
      buyer: b.users?.nickname || b.users?.email || '-',
      buyerPhone: b.users?.phone || '-',
      userId: b.user_id
    }));
    
    return { 
      success: true, 
      breaks: formattedBreaks || []
    };
  } catch (error) {
    console.error('[getAllBreaks] éŒ¯èª¤:', error);
    return { success: false, message: 'æŸ¥è©¢å¤±æ•—: ' + error.message };
  }
}

async function handleUpdateBreak(body, supabase) {
  const { id, status, paid, item, is_opened, is_shipped } = body;
  
  if (!id) {
    return { success: false, message: 'ç¼ºå°‘åœ˜æ‹† ID' };
  }
  
  try {
    console.log('[updateBreak] æ›´æ–°åœ˜æ‹† ID: ' + id, 'ç‹€æ…‹:', status, 'å·²ä»˜é‡‘é¡:', paid, 'è³¼è²·å“é …:', item, 'å·²æ‹†:', is_opened, 'å·²å¯„å‡º:', is_shipped);
    
    const updateData = {};
    if (status !== undefined) updateData.status = status;
    if (paid !== undefined) updateData.paid = parseFloat(paid);
    if (item !== undefined) updateData.item = item;
    if (is_opened !== undefined) updateData.is_opened = is_opened;
    if (is_shipped !== undefined) updateData.is_shipped = is_shipped;
    
    if (Object.keys(updateData).length === 0) {
      return { success: false, message: 'æ²’æœ‰è¦æ›´æ–°çš„æ¬„ä½' };
    }
    
    const updateUrl = `${supabase.url}/rest/v1/breaks?id=eq.${id}`;
    
    const response = await fetch(updateUrl, {
      method: 'PATCH',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'  // ğŸ”‘ è¦æ±‚è¿”å›æ›´æ–°å¾Œçš„è¨˜éŒ„
      },
      body: JSON.stringify(updateData)
    });
    
    console.log('[updateBreak] HTTP ç‹€æ…‹:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[updateBreak] HTTP éŒ¯èª¤:', response.status, errorText);
      return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + response.statusText };
    }
    
    let result = [];
    const responseText = await response.text();
    console.log('[updateBreak] åŸå§‹å›æ‡‰:', responseText);
    
    // ğŸ”‘ åªæœ‰ç•¶å›æ‡‰ä¸ç‚ºç©ºæ™‚æ‰è§£æ JSON
    if (responseText && responseText.trim()) {
      try {
        result = JSON.parse(responseText);
      } catch (parseErr) {
        console.error('[updateBreak] JSON è§£æå¤±æ•—:', parseErr, 'å›æ‡‰å…§å®¹:', responseText);
        result = [];
      }
    }
    
    console.log('[updateBreak] æ›´æ–°æˆåŠŸ:', JSON.stringify(updateData), 'çµæœ:', JSON.stringify(result));
    
    return { 
      success: true, 
      message: 'åœ˜æ‹†å·²æ›´æ–°',
      break: Array.isArray(result) ? result[0] : result
    };
  } catch (error) {
    console.error('[updateBreak] éŒ¯èª¤:', error);
    return { success: false, message: 'æ›´æ–°å¤±æ•—: ' + error.message };
  }
}

// ==================== æ–°å¢åœ˜æ‹†æ‰¹æ¬¡ API ====================

/**
 * æ‰¹æ¬¡æ–°å¢åœ˜æ‹†è¨˜éŒ„
 * å¾ break_order_generator æ¥æ”¶çš„è³‡æ–™æ ¼å¼
 */
async function handleAddBreaksBatch(body, supabase) {
  const { breaks } = body;
  
  if (!Array.isArray(breaks) || breaks.length === 0) {
    return { success: false, message: 'è«‹æä¾›è‡³å°‘ä¸€ç­†åœ˜æ‹†è³‡æ–™' };
  }

  try {
    console.log('[addBreaksBatch] é–‹å§‹æ‰¹æ¬¡æ–°å¢ï¼Œç¸½æ•¸:', breaks.length);
    
    const results = [];
    const errors = [];
    
    for (const breakData of breaks) {
      try {
        const { buyer, breakNumber, category, breakName, breakType, itemName, totalPrice } = breakData;
        
        if (!buyer || !breakNumber || !breakName || !totalPrice) {
          errors.push({
            buyer,
            breakNumber,
            error: 'ç¼ºå°‘å¿…å¡«æ¬„ä½ (è¨‚è³¼äººã€ç·¨è™Ÿã€åç¨±ã€é‡‘é¡)'
          });
          continue;
        }
        
        // æ ¹æ“šè¨‚è³¼äººåç¨±æŸ¥æ‰¾å°æ‡‰çš„ user_id
        console.log('[addBreaksBatch] æŸ¥è©¢è¨‚è³¼äºº:', buyer);
        
        // å…ˆå˜—è©¦ç²¾ç¢ºåŒ¹é…
        let userQueryUrl = `${supabase.url}/rest/v1/users?select=id,phone,nickname,email`;
        const userResp = await fetch(userQueryUrl, {
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`
          }
        });
        
        let allUsers = await userResp.json();
        if (!Array.isArray(allUsers)) {
          allUsers = [];
        }
        
        // å…ˆæŸ¥æ‰¾ç²¾ç¢ºåŒ¹é…
        let matchedUser = allUsers.find(u => u.nickname && u.nickname.trim() === buyer.trim());
        
        // å¦‚æœæ²’æœ‰ç²¾ç¢ºåŒ¹é…ï¼Œå‰‡é€²è¡Œæ¨¡ç³ŠåŒ¹é…
        if (!matchedUser) {
          matchedUser = allUsers.find(u => u.nickname && u.nickname.toLowerCase().includes(buyer.toLowerCase()));
        }
        
        // å¦‚æœé‚„æ˜¯æ²’æ‰¾åˆ°ï¼Œå˜—è©¦æŒ‰é›»è©±è™Ÿç¢¼åŒ¹é…
        if (!matchedUser && buyer.match(/^\d+$/)) {
          matchedUser = allUsers.find(u => u.phone && u.phone.includes(buyer));
        }
        
        let userId;
        if (matchedUser) {
          userId = matchedUser.id;
          console.log('[addBreaksBatch] æ‰¾åˆ°è¨‚è³¼äºº user_id:', userId, 'åç¨±:', matchedUser.nickname);
        } else {
          // é¡¯ç¤ºæ‰€æœ‰å¯ç”¨çš„ä½¿ç”¨è€…ï¼Œæ–¹ä¾¿èª¿è©¦
          const availableUsers = allUsers.map(u => u.nickname).filter(Boolean).join(', ');
          errors.push({
            buyer,
            breakNumber,
            error: `æ‰¾ä¸åˆ°è¨‚è³¼äºº "${buyer}"ã€‚å¯ç”¨çš„ä½¿ç”¨è€…: ${availableUsers || '(ç„¡)'}`
          });
          console.log('[addBreaksBatch] æŸ¥è©¢å¤±æ•—ï¼Œè¼¸å…¥:', buyer, 'å¯ç”¨ä½¿ç”¨è€…:', availableUsers);
          continue;
        }
        
        // è¨ˆç®—æ–°çš„ break_idï¼ˆæ ¹æ“š breakNumber ç”Ÿæˆï¼‰
        // break_id å°±æ˜¯åœ˜æ‹†ç·¨è™Ÿæœ¬èº«ï¼Œæ‰€æœ‰è¨‚è³¼äººå…±ç”¨åŒä¸€å€‹ç·¨è™Ÿ
        // æ¯ç­†è¨˜éŒ„ç”± UUID çš„ id æ¬„ä½å”¯ä¸€è­˜åˆ¥
        const breakId = breakNumber;
        
        // æº–å‚™æ–°å¢çš„è³‡æ–™
        // æ ¹æ“š Supabase breaks è¡¨çš„æ¬„ä½å®šç¾©
        // âš ï¸ balance æ˜¯ generated columnï¼Œä¸èƒ½æ’å…¥å€¼ï¼Œç”±ç³»çµ±è‡ªå‹•è¨ˆç®—
        const newBreak = {
          break_id: breakId,
          user_id: userId,
          name: breakName,
          category: category || 'æ£’çƒ',
          format: breakType || 'éš¨æ©Ÿ',
          item: itemName || '1æ³¨',
          total_fee: parseFloat(totalPrice),
          paid: 0,
          status: 'æœªä»˜æ¬¾',
          is_opened: false,
          is_shipped: false,
          is_cleared: false
        };
        
        console.log('[addBreaksBatch] æ–°å¢è³‡æ–™:', JSON.stringify(newBreak));
        
        // æ–°å¢åˆ°è³‡æ–™åº«
        const insertUrl = `${supabase.url}/rest/v1/breaks`;
        const insertResp = await fetch(insertUrl, {
          method: 'POST',
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=representation'
          },
          body: JSON.stringify(newBreak)
        });
        
        if (!insertResp.ok) {
          const errText = await insertResp.text();
          errors.push({
            buyer,
            breakNumber,
            error: 'æ–°å¢å¤±æ•—: ' + errText
          });
          console.error('[addBreaksBatch] æ–°å¢å¤±æ•—:', errText);
          continue;
        }
        
        const insertResult = await insertResp.json();
        console.log('[addBreaksBatch] âœ… æ–°å¢æˆåŠŸ:', buyer, breakNumber);
        
        results.push({
          buyer,
          breakNumber,
          id: Array.isArray(insertResult) ? insertResult[0]?.id : insertResult?.id,
          success: true
        });
        
      } catch (itemError) {
        console.error('[addBreaksBatch] è™•ç†é …ç›®éŒ¯èª¤:', itemError);
        errors.push({
          buyer: breakData.buyer,
          breakNumber: breakData.breakNumber,
          error: itemError.message
        });
      }
    }
    
    console.log('[addBreaksBatch] å®Œæˆï¼ŒæˆåŠŸ:', results.length, 'å¤±æ•—:', errors.length);
    
    return {
      success: errors.length === 0,
      message: `å·²æ–°å¢ ${results.length} ç­†åœ˜æ‹†${errors.length > 0 ? 'ï¼Œ' + errors.length + ' ç­†å¤±æ•—' : ''}`,
      added: results,
      errors: errors.length > 0 ? errors : null
    };
    
  } catch (error) {
    console.error('[addBreaksBatch] æ‰¹æ¬¡æ–°å¢å¤±æ•—:', error);
    return { 
      success: false, 
      message: 'æ‰¹æ¬¡æ–°å¢å¤±æ•—: ' + error.message 
    };
  }
}

// ==================== åˆªé™¤åœ˜æ‹† API ====================

async function handleDeleteBreak(body, supabase) {
  const { id } = body;
  
  if (!id) {
    return { success: false, message: 'ç¼ºå°‘åœ˜æ‹† ID' };
  }
  
  try {
    console.log('[deleteBreak] åˆªé™¤åœ˜æ‹† ID:', id);
    
    const deleteUrl = `${supabase.url}/rest/v1/breaks?id=eq.${id}`;
    
    const response = await fetch(deleteUrl, {
      method: 'DELETE',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    console.log('[deleteBreak] HTTP ç‹€æ…‹:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[deleteBreak] HTTP éŒ¯èª¤:', response.status, errorText);
      return { success: false, message: 'åˆªé™¤å¤±æ•—: ' + response.statusText };
    }
    
    console.log('[deleteBreak] âœ… åˆªé™¤æˆåŠŸ');
    
    return { 
      success: true, 
      message: 'åœ˜æ‹†å·²åˆªé™¤'
    };
  } catch (error) {
    console.error('[deleteBreak] éŒ¯èª¤:', error);
    return { success: false, message: 'åˆªé™¤å¤±æ•—: ' + error.message };
  }
}

// ==================== åˆªé™¤è¨‚å–® API ====================

async function handleDeleteOrder(body, supabase) {
  const { id } = body;
  
  if (!id) {
    return { success: false, message: 'ç¼ºå°‘è¨‚å–® ID' };
  }
  
  try {
    console.log('[deleteOrder] åˆªé™¤è¨‚å–® ID:', id);
    
    const deleteUrl = `${supabase.url}/rest/v1/orders?id=eq.${id}`;
    
    const response = await fetch(deleteUrl, {
      method: 'DELETE',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    console.log('[deleteOrder] HTTP ç‹€æ…‹:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[deleteOrder] HTTP éŒ¯èª¤:', response.status, errorText);
      return { success: false, message: 'åˆªé™¤å¤±æ•—: ' + response.statusText };
    }
    
    console.log('[deleteOrder] âœ… åˆªé™¤æˆåŠŸ');
    
    return { 
      success: true, 
      message: 'è¨‚å–®å·²åˆªé™¤'
    };
  } catch (error) {
    console.error('[deleteOrder] éŒ¯èª¤:', error);
    return { success: false, message: 'åˆªé™¤å¤±æ•—: ' + error.message };
  }
}

// ==================== å–å¾—æ‰€æœ‰è¨‚å–® API ====================

async function handleGetAllOrders(body, supabase) {
  try {
    console.log('[getAllOrders] æŸ¥è©¢æ‰€æœ‰è¨‚å–®');
    
    const queryUrl = `${supabase.url}/rest/v1/orders?select=*&order=timestamp.desc&limit=10000`;
    
    const response = await fetch(queryUrl, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[getAllOrders] HTTP éŒ¯èª¤:', response.status, errorText);
      return { success: false, message: 'æŸ¥è©¢å¤±æ•—: ' + response.statusText };
    }
    
    const orders = await response.json();
    
    // æŸ¥è©¢æ‰€æœ‰ç”¨æˆ¶ä»¥æä¾›é¡å¤–ä¿¡æ¯
    const userQueryUrl = `${supabase.url}/rest/v1/users?select=id,nickname,phone&limit=1000`;
    const userResponse = await fetch(userQueryUrl, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    let allUsers = [];
    if (userResponse.ok) {
      allUsers = await userResponse.json();
    }
    
    const userMap = new Map();
    if (Array.isArray(allUsers)) {
      allUsers.forEach(u => {
        userMap.set(u.id, u);
      });
    }
    
    // ç‚ºæ¯å€‹è¨‚å–®æ·»åŠ ç”¨æˆ¶ä¿¡æ¯
    const enrichedOrders = Array.isArray(orders) ? orders.map(o => ({
      ...o,
      nickname: userMap.get(o.user_id)?.nickname || 'æœªçŸ¥',
      phone: userMap.get(o.user_id)?.phone || 'æœªçŸ¥'
    })) : [];
    
    console.log('[getAllOrders] âœ… æŸ¥è©¢æˆåŠŸï¼Œæ‰¾åˆ° ' + enrichedOrders.length + ' ç­†è¨‚å–®');
    
    return { 
      success: true, 
      orders: enrichedOrders,
      count: enrichedOrders.length
    };
  } catch (error) {
    console.error('[getAllOrders] éŒ¯èª¤:', error);
    return { success: false, message: 'æŸ¥è©¢å¤±æ•—: ' + error.message };
  }
}

// ==================== ğŸ’³ ç¶ ç•Œé‡‘æµå·¥å…·å‡½å¼ ====================

/**
 * ç”Ÿæˆç¶ ç•Œ CheckMacValue (éåŒæ­¥ç‰ˆæœ¬)
 */
async function generateEcpayCheckMacValue(params) {
  try {
    // 1. ç§»é™¤ CheckMacValue
    const paramsCopy = { ...params };
    delete paramsCopy.CheckMacValue;
    
    // 2. åƒæ•¸åç¨±æ’åº
    const keys = Object.keys(paramsCopy).sort();
    
    // 3. çµ„åˆæˆ query stringï¼ˆä¸å« & å’Œ =ï¼‰
    let data = '';
    for (const key of keys) {
      data += key + '=' + paramsCopy[key];
      data += '&';
    }
    
    // 4. å‰å¾ŒåŠ å…¥ HashKey å’Œ HashIV
    const hashKey = ECPAY_CONFIG.HashKey;
    const hashIV = ECPAY_CONFIG.HashIV;
    
    // 5. URL encode
    const urlEncoded = encodeURIComponent(data)
      .replace(/'/g, '%27')
      .replace(/\*/g, '%2A')
      .replace(/~/g, '%7E')
      .replace(/\+/g, '%20');
    
    const dataToHash = 'HashKey=' + hashKey + '&' + urlEncoded + '&HashIV=' + hashIV;
    
    // 6. SHA256 åŠ å¯† (éåŒæ­¥)
    const hash = await SHA256(dataToHash);
    
    // 7. è½‰å¤§å¯«
    return hash.toUpperCase();
  } catch (error) {
    console.error('[ECPay] CheckMacValue ç”Ÿæˆå¤±æ•—:', error);
    throw error;
  }
}

/**
 * SHA256 é›œæ¹Šå‡½å¼ï¼ˆç°¡åŒ–ç‰ˆï¼Œä½¿ç”¨ crypto APIï¼‰
 */
async function SHA256(message) {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex;
}

/**
 * ç¶ ç•Œå›èª¿è™•ç†ï¼ˆç•°æ­¥ç‰ˆæœ¬ï¼Œç”¨æ–¼ Cloudflare Workersï¼‰
 */
async function handleEcpayCallback(params, supabase) {
  try {
    console.log('[ECPay Callback] é–‹å§‹è™•ç†å›èª¿');
    console.log('[ECPay Callback] æ”¶åˆ°åƒæ•¸æ•¸é‡:', Object.keys(params).length);
    
    console.log('[ECPay] å›èª¿åƒæ•¸:', {
      MerchantTradeNo: params.MerchantTradeNo,
      RtnCode: params.RtnCode,
      RtnMsg: params.RtnMsg,
      TradeNo: params.TradeNo,
      CheckMacValue: params.CheckMacValue ? 'å·²æ”¶åˆ°' : 'ç¼ºå°‘'
    });
    
    // æª¢æŸ¥å¿…è¦åƒæ•¸
    if (!params.MerchantTradeNo || !params.RtnCode) {
      console.error('[ECPay] ç¼ºå°‘å¿…è¦åƒæ•¸');
      return { success: false, message: 'ç¼ºå°‘å¿…è¦åƒæ•¸' };
    }
    
    // é©—è­‰ CheckMacValue
    const receivedCheckMac = params.CheckMacValue;
    if (!receivedCheckMac) {
      console.error('[ECPay] ç¼ºå°‘ CheckMacValue');
      return { success: false, message: 'ç¼ºå°‘ CheckMacValue' };
    }
    
    const paramsCopy = { ...params };
    delete paramsCopy.CheckMacValue;
    
    console.log('[ECPay] æº–å‚™é©—è­‰ CheckMacValueï¼Œåƒæ•¸:', Object.keys(paramsCopy).sort().join(','));
    
    const calculatedCheckMac = await generateEcpayCheckMacValueAsync(paramsCopy);
    
    console.log('[ECPay] CheckMacValue æ¯”å°:');
    console.log('  æ”¶åˆ°:  ', receivedCheckMac);
    console.log('  è¨ˆç®—:  ', calculatedCheckMac);
    
    if (receivedCheckMac !== calculatedCheckMac) {
      console.error('[ECPay] âŒ CheckMacValue é©—è­‰å¤±æ•—!');
      return { success: false, message: 'CheckMacValue é©—è­‰å¤±æ•—' };
    }
    
    console.log('[ECPay] âœ… CheckMacValue é©—è­‰æˆåŠŸ');
    
    const merchantTradeNo = params.MerchantTradeNo;
    const rtnCode = params.RtnCode;
    const tradeNo = params.TradeNo;
    const paymentDate = params.PaymentDate;
    
    // æŸ¥è©¢ç¾æœ‰çš„ä»˜æ¬¾è¨˜éŒ„
    console.log('[ECPay] æŸ¥è©¢ä»˜æ¬¾è¨˜éŒ„:', merchantTradeNo);
    
    // ä½¿ç”¨ fetch ç›´æ¥æŸ¥è©¢ï¼Œæ¯”ç”¨ supabase.query() æ›´å¯é 
    const queryUrl = `${supabase.url}/rest/v1/ecpay_records?merchant_trade_no=eq.${encodeURIComponent(merchantTradeNo)}&select=*`;
    console.log('[ECPay] æŸ¥è©¢ URL:', queryUrl);
    
    const queryResp = await fetch(queryUrl, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    const records = await queryResp.json();
    console.log('[ECPay] æŸ¥è©¢çµæœé¡å‹:', typeof records);
    console.log('[ECPay] æŸ¥è©¢çµæœ:', Array.isArray(records) ? records.length + 'ç­†' : JSON.stringify(records).substring(0, 200));
    
    if (!Array.isArray(records) || records.length === 0) {
      console.error('[ECPay] æ‰¾ä¸åˆ°ä»˜æ¬¾è¨˜éŒ„:', merchantTradeNo);
      console.error('[ECPay] æŸ¥è©¢çµæœ:', records);
      return { success: false, message: 'æ‰¾ä¸åˆ°ä»˜æ¬¾è¨˜éŒ„' };
    }
    
    const record = records[0];
    console.log('[ECPay] æ‰¾åˆ°ä»˜æ¬¾è¨˜éŒ„ï¼Œuser_id:', record.user_id, 'ç‹€æ…‹:', record.status);
    
    // ğŸ”¥ å†ªç­‰æ€§æª¢æŸ¥ï¼šå¦‚æœå·²ç¶“è™•ç†éï¼ˆç‹€æ…‹æ˜¯ successï¼‰ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼Œä¸é‡è¤‡è™•ç†
    if (record.status === 'success' && rtnCode === '1') {
      console.log('[ECPay] âš ï¸ è©²ä»˜æ¬¾å·²è™•ç†éï¼Œè·³éé‡è¤‡è™•ç†ï¼ˆå†ªç­‰æ€§ä¿è­·ï¼‰');
      return { success: true, message: '1|OKï¼ˆå·²è™•ç†éï¼‰' };
    }
    
    // æ›´æ–°ä»˜æ¬¾è¨˜éŒ„ç‹€æ…‹
    const updateUrl = `${supabase.url}/rest/v1/ecpay_records?merchant_trade_no=eq.${encodeURIComponent(merchantTradeNo)}`;
    console.log('[ECPay] æ›´æ–° URL:', updateUrl);
    
    const updateResponse = await fetch(updateUrl, {
      method: 'PATCH',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        status: rtnCode === '1' ? 'success' : 'failed',
        trade_no: tradeNo,
        payment_date: paymentDate,
        trade_amt: params.Amt || params.TotalAmount,
        updated_at: new Date().toISOString()
      })
    });
    
    if (!updateResponse.ok) {
      const errorText = await updateResponse.text();
      console.error('[ECPay] æ›´æ–°ä»˜æ¬¾è¨˜éŒ„å¤±æ•—:', updateResponse.status, errorText);
      return { success: false, message: 'æ›´æ–°è¨˜éŒ„å¤±æ•—: ' + errorText };
    }
    
    // å®‰å…¨åœ°è®€å– JSONï¼Œå¯èƒ½ç‚ºç©º
    let updateResult = {};
    const responseText = await updateResponse.text();
    if (responseText) {
      try {
        updateResult = JSON.parse(responseText);
      } catch (e) {
        console.warn('[ECPay] æ›´æ–°çµæœä¸æ˜¯æœ‰æ•ˆ JSON:', responseText.substring(0, 100));
      }
    }
    console.log('[ECPay] âœ… ä»˜æ¬¾è¨˜éŒ„å·²æ›´æ–°ï¼Œç‹€æ…‹:', rtnCode === '1' ? 'success' : 'failed');
    
    // å¦‚æœä»˜æ¬¾æˆåŠŸï¼Œæ›´æ–°è¨‚å–®ç‹€æ…‹ä¸¦ä¿å­˜é€šçŸ¥
    if (rtnCode === '1') {
      // å¾ user_id æŸ¥è©¢ä½¿ç”¨è€…è³‡è¨Š
      const userInfo = await supabase.query('users', { eq: { id: record.user_id } });
      const user = Array.isArray(userInfo) && userInfo.length > 0 ? userInfo[0] : {};
      
      // è§£æ order_details ä¸¦æ›´æ–°å°æ‡‰çš„è¨‚å–®
      try {
        let orderDetailsArray = [];
        if (record.order_details) {
          if (typeof record.order_details === 'string') {
            orderDetailsArray = JSON.parse(record.order_details);
          } else {
            orderDetailsArray = record.order_details;
          }
        }
        
        console.log('[ECPay] é–‹å§‹æ›´æ–°è¨‚å–®ï¼Œæ•¸é‡:', orderDetailsArray.length);
        console.log('[ECPay] order_ids:', record.order_ids);
        console.log('[ECPay] payment_type:', record.payment_type);
        
        // åˆ¤æ–·ä»˜æ¬¾é¡å‹ï¼šorder æˆ– break
        const paymentType = record.payment_type || 'order';
        
        if (paymentType === 'order') {
          // è¨‚å–®ä»˜æ¬¾ï¼šæ ¹æ“š order_idsï¼ˆUUIDï¼‰æ›´æ–° orders è¡¨
          const orderIds = record.order_ids ? record.order_ids.split(',').map(id => id.trim()) : [];
          console.log('[ECPay] é€²å…¥è¨‚å–®æ›´æ–°åˆ†æ”¯ï¼Œè¦æ›´æ–°çš„è¨‚å–® IDs:', orderIds);
          
          for (const orderId of orderIds) {
            if (!orderId) {
              console.log('[ECPay] âš ï¸ è·³éç©ºçš„ orderId');
              continue;
            }
            
            console.log('[ECPay] é–‹å§‹æ›´æ–°è¨‚å–® ID:', orderId);
            
            // ç›´æ¥ç”¨è¨‚å–® ID æŸ¥è©¢
            const matchingOrders = await supabase.query('orders', { eq: { id: orderId } });
            console.log('[ECPay] æŸ¥è©¢è¨‚å–®çµæœ:', Array.isArray(matchingOrders) ? `æ‰¾åˆ° ${matchingOrders.length} ç­†` : 'éé™£åˆ—');
            
            if (Array.isArray(matchingOrders) && matchingOrders.length > 0) {
              const order = matchingOrders[0];
              console.log('[ECPay] âœ… æ‰¾åˆ°è¨‚å–®:', orderId, 'åŸç‹€æ…‹:', order.status, 'åŸå°¾æ¬¾:', order.balance_amount);
              
              // æ›´æ–°è¨‚å–®ï¼šè¨­ç½®å°¾æ¬¾ç‚º 0ï¼Œç‹€æ…‹ç‚ºå·²ä»˜æ¬¾
              const updateOrderUrl = `${supabase.url}/rest/v1/orders?id=eq.${orderId}`;
              console.log('[ECPay] æº–å‚™æ›´æ–° URL:', updateOrderUrl);
              
              const orderUpdateResponse = await fetch(updateOrderUrl, {
                method: 'PATCH',
                headers: {
                  'apikey': supabase.apiKey,
                  'Authorization': `Bearer ${supabase.apiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  balance_amount: 0,
                  status: 'å·²ä»˜æ¬¾',
                  updated_at: new Date().toISOString()
                })
              });
              
              console.log('[ECPay] è¨‚å–®æ›´æ–° HTTP ç‹€æ…‹:', orderUpdateResponse.status);
              
              if (orderUpdateResponse.ok) {
                console.log('[ECPay] âœ… è¨‚å–®å·²æ›´æ–° - ID:', orderId, 'å°¾æ¬¾è¨­ç‚º 0ï¼Œç‹€æ…‹æ”¹ç‚ºï¼šå·²ä»˜æ¬¾');
              } else {
                const errorText = await orderUpdateResponse.text();
                console.error('[ECPay] âŒ è¨‚å–®æ›´æ–°å¤±æ•—:', orderId, 'HTTP', orderUpdateResponse.status, 'éŒ¯èª¤:', errorText);
              }
            } else {
              console.warn('[ECPay] âš ï¸ æ‰¾ä¸åˆ°è¨‚å–® ID:', orderId, 'æŸ¥è©¢çµæœ:', matchingOrders);
            }
          }
        } else if (paymentType === 'break') {
          // åœ˜æ‹†ä»˜æ¬¾ï¼šæ ¹æ“š orderDetails ä¸­æ¯ç­†çš„å¯¦éš›é‡‘é¡æ›´æ–°
          console.log('[ECPay] é€²å…¥åœ˜æ‹†æ›´æ–°åˆ†æ”¯ï¼Œç”¨æˆ¶ID:', record.user_id);
          console.log('[ECPay] orderDetails å…§å®¹:', JSON.stringify(orderDetailsArray, null, 2));
          
          for (const detail of orderDetailsArray) {
            const breakId = detail.breakId;
            const payAmount = Number(detail.balance || 0); // ğŸ”¥ ä½¿ç”¨ orderDetails ä¸­è¨˜éŒ„çš„å¯¦éš›é‡‘é¡
            const usedCredit = Number(detail.usedCredit || 0); // ğŸŒŸ å‰ç«¯å‚³ä¾†çš„åœ˜æ‹†é‡‘é‡‘é¡
            const totalFeeFromDetail = Number(detail.totalFee || 0); // ğŸŒŸ ç¸½åœ˜è²»
            
            if (!breakId || payAmount <= 0) {
              console.log('[ECPay] âš ï¸ è·³éç„¡æ•ˆçš„ detail:', detail);
              continue;
            }
            
            console.log('[ECPay] è™•ç†åœ˜æ‹†:', breakId, 'è¦ä»˜é‡‘é¡:', payAmount, 'ä½¿ç”¨åœ˜æ‹†é‡‘:', usedCredit);
            
            // ğŸ”¥ ä½¿ç”¨ break_id å’Œ user_id æŸ¥è©¢åœ˜æ‹†è¨˜éŒ„
            const matchingBreaks = await supabase.query('breaks', { eq: { break_id: breakId, user_id: record.user_id } });
            
            if (Array.isArray(matchingBreaks) && matchingBreaks.length > 0) {
              const breakRecord = matchingBreaks[0];
              console.log('[ECPay] âœ… æ‰¾åˆ°åœ˜æ‹†è¨˜éŒ„:', breakId, 'ç”¨æˆ¶:', record.user_id, 'è¨˜éŒ„ ID:', breakRecord.id);
              
              // è¨ˆç®—æ–°çš„å·²ä»˜é‡‘é¡ï¼ˆåªåŠ ä¸Šé€™ç­†åœ˜æ‹†æ‡‰ä»˜çš„é‡‘é¡ï¼‰
              const currentPaid = Number(breakRecord.paid || 0);
              const newPaid = currentPaid + payAmount;
              const totalFee = totalFeeFromDetail || Number(breakRecord.total_fee || 0);
              
              // ğŸŒŸ åˆ¤æ–·æ˜¯å¦å·²çµæ¸…: paid + åœ˜æ‹†é‡‘ >= totalFee
              const isCleared = (newPaid + usedCredit) >= totalFee;
              
              console.log('[ECPay] ä»˜æ¬¾æ˜ç´° - åŸå·²ä»˜:', currentPaid, 'æœ¬æ¬¡ä»˜:', payAmount, 'æ–°å·²ä»˜:', newPaid, 'åœ˜æ‹†é‡‘:', usedCredit, 'ç¸½åœ˜è²»:', totalFee, 'å·²çµæ¸…:', isCleared);
              
              const updateBreakUrl = `${supabase.url}/rest/v1/breaks?id=eq.${breakRecord.id}`;
              
              const breakUpdateResponse = await fetch(updateBreakUrl, {
                method: 'PATCH',
                headers: {
                  'apikey': supabase.apiKey,
                  'Authorization': `Bearer ${supabase.apiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  paid: newPaid,
                  status: isCleared ? 'å·²çµæ¸…' : 'å·²ä»˜è¨‚é‡‘',
                  updated_at: new Date().toISOString()
                })
              });
              
              if (breakUpdateResponse.ok) {
                console.log('[ECPay] âœ… åœ˜æ‹†å·²æ›´æ–° - ç·¨è™Ÿ:', breakId, 'å·²ä»˜:', newPaid, 'ç¸½é¡:', totalFee);
              } else {
                const errorText = await breakUpdateResponse.text();
                console.error('[ECPay] âŒ åœ˜æ‹†æ›´æ–°å¤±æ•—:', breakId, breakUpdateResponse.status, errorText);
              }
            } else {
              console.warn('[ECPay] âš ï¸ æ‰¾ä¸åˆ°åœ˜æ‹†è¨˜éŒ„:', breakId, 'ç”¨æˆ¶:', record.user_id);
            }
          }
        }
      } catch (updateErr) {
        console.error('[ECPay] æ›´æ–°è¨‚å–®/åœ˜æ‹†æ™‚ç™¼ç”ŸéŒ¯èª¤:', updateErr);
      }
      
      // å»ºç«‹æ”¯ä»˜é€šçŸ¥åˆ° notifications è¡¨ï¼ˆä¾›å¾Œå°æŸ¥çœ‹ï¼‰
      const notification = {
        type: 'payment',
        title: 'ç¶ ç•Œä»˜æ¬¾å®Œæˆ',
        content: JSON.stringify({
          merchant_trade_no: merchantTradeNo,
          user_id: record.user_id,
          phone: user.phone || '',
          nickname: user.nickname || '',
          amount: record.trade_amt,
          item_name: record.item_name,
          order_ids: record.order_ids,
          trade_no: tradeNo,
          payment_date: paymentDate,
          paymentMethod: 'ecpay',
          status: 'success'
        }),
        status: 'unread',
        created_at: new Date().toISOString()
      };
      
      console.log('[ECPay] å»ºç«‹æ”¯ä»˜é€šçŸ¥...');
      try {
        const notifUrl = `${supabase.url}/rest/v1/notifications`;
        const notifResponse = await fetch(notifUrl, {
          method: 'POST',
          headers: {
            'apikey': supabase.apiKey,
            'Authorization': `Bearer ${supabase.apiKey}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=representation'
          },
          body: JSON.stringify(notification)
        });
        
        if (notifResponse.ok) {
          console.log('[ECPay] âœ… å·²å»ºç«‹æ”¯ä»˜é€šçŸ¥');
        } else {
          console.warn('[ECPay] âš ï¸ é€šçŸ¥å»ºç«‹å¤±æ•—:', notifResponse.status);
        }
      } catch (notifErr) {
        console.error('[ECPay] å»ºç«‹é€šçŸ¥æ™‚ç™¼ç”ŸéŒ¯èª¤:', notifErr);
      }
    }
    
    return { success: true, message: 'å›èª¿è™•ç†å®Œæˆï¼ŒRtnCode: ' + rtnCode };
  } catch (error) {
    console.error('[ECPay Callback] éŒ¯èª¤:', error.message || error);
    console.error('[ECPay Callback] å †æ£§:', error.stack);
    return { success: false, message: 'å›èª¿è™•ç†å¤±æ•—: ' + (error.message || String(error)) };
  }
}

/**
 * åŒæ­¥ç‰ˆæœ¬çš„ CheckMacValue ç”Ÿæˆï¼ˆç”¨æ–¼å›èª¿é©—è­‰ï¼‰
 * æ³¨ï¼šé€™åœ¨ Cloudflare Workers ç’°å¢ƒä¸­éœ€è¦éåŒæ­¥ï¼Œæ‰€ä»¥æ”¹ç”¨ç•°æ­¥ç‰ˆæœ¬
 */
async function generateEcpayCheckMacValueAsync(params) {
  try {
    const paramsCopy = { ...params };
    
    // ç§»é™¤ CheckMacValue (å¦‚æœå­˜åœ¨)
    delete paramsCopy.CheckMacValue;
    
    // æ’åºåƒæ•¸ï¼ˆæŒ‰ç…§ A-Z æ’åºï¼‰
    const sortedKeys = Object.keys(paramsCopy).sort();
    
    // çµ„åˆåƒæ•¸å­—ä¸²
    let paramStr = '';
    for (let i = 0; i < sortedKeys.length; i++) {
      paramStr += sortedKeys[i] + '=' + paramsCopy[sortedKeys[i]];
      if (i < sortedKeys.length - 1) {
        paramStr += '&';
      }
    }
    
    const hashKey = ECPAY_CONFIG.HashKey;
    const hashIV = ECPAY_CONFIG.HashIV;
    
    // åŠ ä¸Š HashKey å’Œ HashIV
    const rawStr = 'HashKey=' + hashKey + '&' + paramStr + '&HashIV=' + hashIV;
    
    console.log('åŸå§‹åƒæ•¸:', paramStr);
    
    // URL Encode (å®Œæ•´ç·¨ç¢¼)
    let encodedStr = encodeURIComponent(rawStr);
    
    console.log('URL ç·¨ç¢¼å¾Œ:', encodedStr);
    
    // è½‰å°å¯«
    encodedStr = encodedStr.toLowerCase();
    
    console.log('è½‰å°å¯«å¾Œ:', encodedStr);
    
    // ç‰¹æ®Šå­—ç¬¦é‚„åŸï¼ˆç¶ ç•Œçš„ .NET URL Encode è¦å‰‡ï¼‰
    encodedStr = encodedStr
      .replace(/%2d/g, '-')   // -
      .replace(/%5f/g, '_')   // _
      .replace(/%2e/g, '.')   // .
      .replace(/%21/g, '!')   // !
      .replace(/%2a/g, '*')   // *
      .replace(/%28/g, '(')   // (
      .replace(/%29/g, ')')   // )
      .replace(/%20/g, '+');  // ç©ºæ ¼è½‰ç‚º +
    
    console.log('ç‰¹æ®Šå­—ç¬¦é‚„åŸå¾Œ:', encodedStr);
    
    // SHA256 åŠ å¯†
    const msgBuffer = new TextEncoder().encode(encodedStr);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const checkMacValue = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
    
    console.log('æœ€çµ‚ CheckMacValue:', checkMacValue);
    
    return checkMacValue;
  } catch (error) {
    console.error('[ECPay] CheckMacValue éåŒæ­¥ç”Ÿæˆå¤±æ•—:', error);
    throw error;
  }
}

/**
 * SHA256 åŒæ­¥å¯¦ç¾ï¼ˆä½¿ç”¨ SubtleCryptoï¼‰
 * æ³¨ï¼šCloudflare Workers æ”¯æŒ crypto.subtle
 */
function SHA256Sync(message) {
  // ç°¡æ˜“å¯¦ç¾ï¼šä½¿ç”¨ crypto.getRandomValues ä½œç‚ºå‚™é¸
  // å¯¦éš›æ‡‰ä½¿ç”¨æ­£ç¢ºçš„ SHA256ï¼Œä½†åœ¨ Workers ç’°å¢ƒå¯èƒ½éœ€è¦ç‰¹æ®Šè™•ç†
  const msgBuffer = new TextEncoder().encode(message);
  // è¿”å›æš«æ™‚çš„é ç•™ä½ç½®ï¼Œå¯¦éš›æœƒé€ééåŒæ­¥èª¿ç”¨
  return hmacSHA256(message, '');
}

/**
 * åŸºæ–¼ HMAC çš„è‡¨æ™‚å¯¦ç¾
 */
function hmacSHA256(message, secret) {
  // é€™æ˜¯ç°¡åŒ–ç‰ˆæœ¬ï¼Œå¯¦éš›å¯¦ç¾éœ€è¦æ­£ç¢ºçš„ SHA256
  // åœ¨ Cloudflare Workers ä¸­æ‡‰è©²ä½¿ç”¨ crypto.subtle
  const hash = require('crypto').createHmac('sha256', secret).update(message).digest('hex');
  return hash;
}

// ==================== å‡ºè²¨ç®¡ç†åŠŸèƒ½ ====================

/**
 * ğŸ” æ¸¬è©¦ç”¨ï¼šæŸ¥è©¢ç‰¹å®šç”¨æˆ¶çš„è¨‚å–®ç‹€æ…‹
 */
async function handleDebugUserOrders(body, supabase) {
  try {
    const { phone } = body;
    
    console.log('[DEBUG_USER] æŸ¥è©¢ç”¨æˆ¶:', phone);
    
    // æŸ¥è©¢ç”¨æˆ¶
    const usersUrl = `${supabase.url}/rest/v1/users?phone=eq.${phone}&select=*`;
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    };
    
    const userRes = await fetch(usersUrl, { headers });
    const users = await userRes.json();
    
    if (!users || users.length === 0) {
      return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
    }
    
    const user = users[0];
    console.log('[DEBUG_USER] ç”¨æˆ¶ ID:', user.id, 'nickname:', user.nickname);
    
    // æŸ¥è©¢è©²ç”¨æˆ¶çš„æ‰€æœ‰è¨‚å–®
    const ordersUrl = `${supabase.url}/rest/v1/orders?user_id=eq.${user.id}&select=*&order=timestamp.desc`;
    const ordersRes = await fetch(ordersUrl, { headers });
    const orders = await ordersRes.json();
    
    console.log('[DEBUG_USER] è¨‚å–®ç¸½æ•¸:', orders.length);
    
    orders.forEach((order, idx) => {
      console.log(`[DEBUG_USER] è¨‚å–® #${idx + 1}:`, {
        id: order.id,
        item: order.item,
        card_no: order.card_no,
        quantity: order.quantity,
        arrival_status: order.arrival_status || '(null)',
        is_shipped: order.is_shipped === null ? '(null)' : order.is_shipped,
        timestamp: order.timestamp
      });
    });
    
    // æ¸¬è©¦æŸ¥è©¢æ¢ä»¶
    const testUrl1 = `${supabase.url}/rest/v1/orders?user_id=eq.${user.id}&is_shipped=eq.false&select=id,item,is_shipped`;
    const testUrl2 = `${supabase.url}/rest/v1/orders?user_id=eq.${user.id}&or=(is_shipped.is.null,is_shipped.eq.false)&select=id,item,is_shipped`;
    
    const [test1Res, test2Res] = await Promise.all([
      fetch(testUrl1, { headers }),
      fetch(testUrl2, { headers })
    ]);
    
    const test1 = await test1Res.json();
    const test2 = await test2Res.json();
    
    console.log('[DEBUG_USER] æŸ¥è©¢æ¸¬è©¦ - is_shipped=eq.false:', test1.length, 'ç­†');
    console.log('[DEBUG_USER] æŸ¥è©¢æ¸¬è©¦ - or=(is_shipped.is.null,is_shipped.eq.false):', test2.length, 'ç­†');
    
    return {
      success: true,
      user: { id: user.id, nickname: user.nickname, phone: user.phone },
      totalOrders: orders.length,
      orders: orders.map(o => ({
        id: o.id,
        item: o.item,
        card_no: o.card_no,
        quantity: o.quantity,
        arrival_status: o.arrival_status,
        is_shipped: o.is_shipped,
        timestamp: o.timestamp
      })),
      queryTest: {
        method1_eq_false: test1.length,
        method2_or_null_false: test2.length
      }
    };
  } catch (error) {
    console.error('[DEBUG_USER] Error:', error);
    return { success: false, message: error.message };
  }
}

/**
 * ç”Ÿæˆå‡ºè²¨å ±è¡¨ - æŸ¥è©¢ç¬¦åˆå‡ºè²¨æ¢ä»¶çš„è¨‚å–®
 */
async function handleGenerateShippingReport(body, supabase) {
  try {
    // æŸ¥è©¢æ‰€æœ‰æœªå‡ºè²¨çš„è¨‚å–®å’Œåœ˜æ‹†
    // ğŸ”§ ä½¿ç”¨ or æ¢ä»¶ï¼šis_shipped ç‚º nullã€false æˆ– 'false' éƒ½ç®—æœªå‡ºè²¨
    const ordersUrl = `${supabase.url}/rest/v1/orders?select=*,users!inner(*)&or=(is_shipped.is.null,is_shipped.eq.false)&order=user_id,timestamp`;
    const breaksUrl = `${supabase.url}/rest/v1/breaks?select=*,users!inner(*)&or=(is_shipped.is.null,is_shipped.eq.false)&order=user_id,created_at`;
    
    const headers = {
      'apikey': supabase.apiKey,
      'Authorization': `Bearer ${supabase.apiKey}`
    };
    
    const [ordersRes, breaksRes] = await Promise.all([
      fetch(ordersUrl, { headers }),
      fetch(breaksUrl, { headers })
    ]);
    
    const orders = await ordersRes.json();
    const breaks = await breaksRes.json();
    
    console.log('[SHIPPING_REPORT] ========== é–‹å§‹ç”Ÿæˆå‡ºè²¨å ±è¡¨ ==========');
    console.log('[SHIPPING_REPORT] æŸ¥è©¢åˆ°', Array.isArray(orders) ? orders.length : 0, 'ç­†æœªå‡ºè²¨è¨‚å–®');
    
    // ğŸ” é¡¯ç¤ºå‰3ç­†è¨‚å–®çš„è©³ç´°è³‡æ–™
    if (Array.isArray(orders) && orders.length > 0) {
      console.log('[SHIPPING_REPORT] å‰3ç­†è¨‚å–®æ¨£æœ¬:');
      orders.slice(0, 3).forEach((o, idx) => {
        console.log(`  [${idx + 1}] user_id: ${o.user_id}, phone: ${o.users?.phone}, item: ${o.item}, card_no: ${o.card_no}, arrival_status: '${o.arrival_status}', is_shipped: ${o.is_shipped}`);
      });
    }
    
    // æŒ‰ç”¨æˆ¶åˆ†çµ„
    const userMap = new Map();
    
    // è™•ç†è¨‚å–®
    if (Array.isArray(orders)) {
      for (const order of orders) {
        const userId = order.user_id;
        if (!userMap.has(userId)) {
          userMap.set(userId, {
            userId,
            nickname: order.users?.nickname || '',
            realName: order.users?.real_name || '',
            phone: order.users?.phone || '',
            cvsStoreName: order.users?.cvs_store_name || '',
            cvsStoreId: order.users?.cvs_store_id || '',
            orders: [],
            breaks: [],
            totalCards: 0,
            hasArrivedBox: false,
            hasBreakCards: false,
            canShip: false
          });
        }
        
        const user = userMap.get(userId);
        user.orders.push(order);
        
        // è¨ˆç®—ç´¯ç©å¼µæ•¸
        if (order.item && order.card_no) {
          user.totalCards += parseInt(order.quantity) || 0;
        }
        
        // ğŸ” æª¢æŸ¥è¨‚å–®çš„åˆ°è²¨ç‹€æ…‹
        // ä¸‹å–®æ™‚å·²ç¶“å¾å•†å“ç›®éŒ„åŒæ­¥ arrival_statusï¼Œç›´æ¥ä½¿ç”¨å³å¯
        let orderArrived = false;
        if (order.arrival_status === 'V') {
          console.log('[SHIPPING_REPORT] âœ… è¨‚å–®å·²åˆ°è²¨:', order.item, order.card_no, 'arrival_status:', order.arrival_status);
          user.hasArrivedBox = true;
          orderArrived = true;
        } else {
          console.log('[SHIPPING_REPORT] â³ è¨‚å–®æœªåˆ°è²¨:', order.item, order.card_no, 'arrival_status:', order.arrival_status || '(ç©ºå€¼)');
        }
        
        // è¨˜éŒ„è¨‚å–®çš„åˆ°è²¨ç‹€æ…‹ï¼ˆç”¨æ–¼å¾ŒçºŒåˆ¤æ–·æ˜¯å¦å…¨éƒ¨åˆ°è²¨ï¼‰
        order._arrived = orderArrived;
      }
    }
    
    // è™•ç†åœ˜æ‹†
    if (Array.isArray(breaks)) {
      breaks.forEach(breakRecord => {
        const userId = breakRecord.user_id;
        if (!userMap.has(userId)) {
          userMap.set(userId, {
            userId,
            nickname: breakRecord.users?.nickname || '',
            realName: breakRecord.users?.real_name || '',
            phone: breakRecord.users?.phone || '',
            cvsStoreName: breakRecord.users?.cvs_store_name || '',
            cvsStoreId: breakRecord.users?.cvs_store_id || '',
            orders: [],
            breaks: [],
            totalCards: 0,
            hasArrivedBox: false,
            hasBreakCards: false,
            canShip: false
          });
        }
        
        const user = userMap.get(userId);
        user.breaks.push(breakRecord);
        
        // æª¢æŸ¥æ˜¯å¦æœ‰å·²é–‹ç®±çš„åœ˜æ‹†
        if (breakRecord.is_opened) {
          user.hasBreakCards = true;
        }
      });
    }
    
    // åˆ¤æ–·å‡ºè²¨æ¢ä»¶
    userMap.forEach(user => {
      // ğŸ†• æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è¨‚å–®éƒ½å·²åˆ°è²¨
      let allOrdersArrived = false;
      if (user.orders.length > 0) {
        allOrdersArrived = user.orders.every(order => order._arrived === true);
        console.log(`[SHIPPING_REPORT] ç”¨æˆ¶ ${user.nickname} (${user.phone}) è¨‚å–®åˆ°è²¨æª¢æŸ¥: ${user.orders.length}ç­†è¨‚å–®, å·²åˆ°è²¨: ${user.orders.filter(o => o._arrived).length}ç­†, å…¨éƒ¨åˆ°è²¨: ${allOrdersArrived}`);
      }
      
      // å‡ºè²¨æ¢ä»¶ï¼š
      // (1)å–®å¡ç´¯ç©10å¼µä»¥ä¸Š 
      // (2)æœ‰å·²åˆ°è²¨çš„å¡ç›’ 
      // (3)æœ‰å·²é–‹ç®±çš„åœ˜æ‹†å¡ç‰‡
      // (4)ğŸ†• æ‰€æœ‰è¨‚è³¼å•†å“éƒ½å·²åˆ°è²¨
      user.canShip = user.totalCards >= 10 || user.hasArrivedBox || user.hasBreakCards || allOrdersArrived;
      user.allOrdersArrived = allOrdersArrived; // è¨˜éŒ„æ­¤ç‹€æ…‹ä¾›å‰ç«¯é¡¯ç¤º
      
      if (user.canShip) {
        console.log('[SHIPPING_REPORT] âœ… ç”¨æˆ¶ç¬¦åˆå‡ºè²¨æ¢ä»¶:', user.nickname, '(', user.phone, ')',
          '\n  - ç´¯ç©å¼µæ•¸:', user.totalCards, '(éœ€>=10)',
          '\n  - æœ‰åˆ°è²¨å¡ç›’:', user.hasArrivedBox,
          '\n  - æœ‰åœ˜æ‹†å¡ç‰‡:', user.hasBreakCards,
          '\n  - å…¨éƒ¨è¨‚å–®å·²åˆ°è²¨:', allOrdersArrived);
      } else {
        console.log('[SHIPPING_REPORT] âŒ ç”¨æˆ¶ä¸ç¬¦åˆå‡ºè²¨æ¢ä»¶:', user.nickname, '(', user.phone, ')',
          '\n  - ç´¯ç©å¼µæ•¸:', user.totalCards, '(éœ€>=10)',
          '\n  - æœ‰åˆ°è²¨å¡ç›’:', user.hasArrivedBox,
          '\n  - æœ‰åœ˜æ‹†å¡ç‰‡:', user.hasBreakCards,
          '\n  - å…¨éƒ¨è¨‚å–®å·²åˆ°è²¨:', allOrdersArrived);
      }
    });
    
    // åªè¿”å›ç¬¦åˆå‡ºè²¨æ¢ä»¶çš„ç”¨æˆ¶
    const shippableUsers = Array.from(userMap.values()).filter(u => u.canShip);
    
    console.log('[SHIPPING_REPORT] ========== å ±è¡¨ç”Ÿæˆå®Œæˆ ==========');
    console.log('[SHIPPING_REPORT] ç¸½ç”¨æˆ¶æ•¸:', userMap.size);
    console.log('[SHIPPING_REPORT] ç¬¦åˆå‡ºè²¨æ¢ä»¶çš„ç”¨æˆ¶æ•¸:', shippableUsers.length);
    console.log('[SHIPPING_REPORT] =====================================');
    
    return {
      success: true,
      users: shippableUsers,
      totalUsers: shippableUsers.length
    };
  } catch (error) {
    console.error('[SHIPPING_REPORT] Error:', error);
    return { success: false, message: 'ç”Ÿæˆå‡ºè²¨å ±è¡¨å¤±æ•—: ' + error.message };
  }
}

/**
 * å»ºç«‹å‡ºè²¨ç´€éŒ„
 */
async function handleCreateShipment(body, supabase) {
  try {
    const { userId, orderIds, breakIds, trackingNo, remark } = body;
    
    if (!userId) {
      return { success: false, message: 'ç¼ºå°‘ç”¨æˆ¶ ID' };
    }
    
    // æŸ¥è©¢ç”¨æˆ¶è³‡æ–™
    const userUrl = `${supabase.url}/rest/v1/users?id=eq.${userId}`;
    const userRes = await fetch(userUrl, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`
      }
    });
    const users = await userRes.json();
    
    if (!Array.isArray(users) || users.length === 0) {
      return { success: false, message: 'æ‰¾ä¸åˆ°ç”¨æˆ¶' };
    }
    
    const user = users[0];
    
    // æŸ¥è©¢è¨‚å–®å’Œåœ˜æ‹†çš„è©³ç´°è³‡æ–™
    let items = [];
    
    if (orderIds && orderIds.length > 0) {
      const ordersUrl = `${supabase.url}/rest/v1/orders?id=in.(${orderIds.join(',')})`;
      const ordersRes = await fetch(ordersUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      const orders = await ordersRes.json();
      
      if (Array.isArray(orders)) {
        orders.forEach(o => {
          items.push(`${o.item} ${o.card_no} x${o.quantity}`);
        });
      }
    }
    
    if (breakIds && breakIds.length > 0) {
      const breaksUrl = `${supabase.url}/rest/v1/breaks?break_id=in.(${breakIds.map(id => `"${id}"`).join(',')})`;
      const breaksRes = await fetch(breaksUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      const breaks = await breaksRes.json();
      
      if (Array.isArray(breaks)) {
        breaks.forEach(b => {
          items.push(`åœ˜æ‹†: ${b.name}`);
        });
      }
    }
    
    // ç”Ÿæˆå‡ºè²¨ç·¨è™Ÿ
    const shipmentNo = 'SHIP-' + Date.now();
    const shipmentDate = new Date().toISOString().split('T')[0];
    
    // å»ºç«‹å‡ºè²¨ç´€éŒ„
    const shipmentData = {
      user_id: userId,
      shipment_no: shipmentNo,
      shipment_date: shipmentDate,
      tracking_no: trackingNo || null,
      items: items.join('; '),
      status: 'å·²å‡ºè²¨',
      nickname: user.nickname,
      real_name: user.real_name,
      phone: user.phone,
      ship_store: user.cvs_store_name,
      store_number: user.cvs_store_id,
      remark: remark || null
    };
    
    const insertUrl = `${supabase.url}/rest/v1/shipments`;
    const insertRes = await fetch(insertUrl, {
      method: 'POST',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify(shipmentData)
    });
    
    if (!insertRes.ok) {
      const errorText = await insertRes.text();
      return { success: false, message: 'å»ºç«‹å‡ºè²¨ç´€éŒ„å¤±æ•—: ' + errorText };
    }
    
    // æ›´æ–°è¨‚å–®å’Œåœ˜æ‹†ç‚ºå·²å‡ºè²¨
    if (orderIds && orderIds.length > 0) {
      const updateOrdersUrl = `${supabase.url}/rest/v1/orders?id=in.(${orderIds.join(',')})`;
      await fetch(updateOrdersUrl, {
        method: 'PATCH',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ is_shipped: true })
      });
    }
    
    if (breakIds && breakIds.length > 0) {
      const updateBreaksUrl = `${supabase.url}/rest/v1/breaks?break_id=in.(${breakIds.map(id => `"${id}"`).join(',')})`;
      await fetch(updateBreaksUrl, {
        method: 'PATCH',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ is_shipped: true })
      });
    }
    
    const shipment = await insertRes.json();
    
    return {
      success: true,
      message: 'å‡ºè²¨ç´€éŒ„å·²å»ºç«‹',
      shipment: Array.isArray(shipment) ? shipment[0] : shipment
    };
  } catch (error) {
    console.error('[CREATE_SHIPMENT] Error:', error);
    return { success: false, message: 'å»ºç«‹å‡ºè²¨ç´€éŒ„å¤±æ•—: ' + error.message };
  }
}

/**
 * æŸ¥è©¢æ‰€æœ‰å‡ºè²¨ç´€éŒ„
 */
async function handleGetAllShipments(body, supabase) {
  try {
    const { limit = 100, offset = 0 } = body;
    
    // ä½¿ç”¨ JOIN ä¾†å–å¾—ä½¿ç”¨è€…è³‡æ–™
    const url = `${supabase.url}/rest/v1/shipments?select=*,users!inner(nickname,real_name,phone,cvs_store_name,cvs_store_id)&order=created_at.desc&limit=${limit}&offset=${offset}`;
    const response = await fetch(url, {
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`
      }
    });
    
    if (response.ok) {
      const shipments = await response.json();
      
      // å°‡ users è³‡æ–™å¹³æ”¤åˆ° shipment å±¤ç´š
      const formattedShipments = shipments.map(s => ({
        ...s,
        nickname: s.users?.nickname || s.nickname,
        real_name: s.users?.real_name || s.real_name,
        phone: s.users?.phone || s.phone,
        ship_store: s.users?.cvs_store_name || s.ship_store,
        store_number: s.users?.cvs_store_id || s.store_number
      }));
      
      return { success: true, shipments: formattedShipments };
    } else {
      const errorText = await response.text();
      return { success: false, message: 'æŸ¥è©¢å‡ºè²¨ç´€éŒ„å¤±æ•—: ' + errorText };
    }
  } catch (error) {
    console.error('[GET_ALL_SHIPMENTS] Error:', error);
    return { success: false, message: 'æŸ¥è©¢å‡ºè²¨ç´€éŒ„å¤±æ•—: ' + error.message };
  }
}

/**
 * æ‰¹æ¬¡æ›´æ–°ç‰©æµå–®è™Ÿ
 */
async function handleBatchUpdateTrackingNumbers(body, supabase) {
  try {
    const { updates } = body;
    
    if (!Array.isArray(updates) || updates.length === 0) {
      return { success: false, message: 'æœªæä¾›æ›´æ–°è³‡æ–™' };
    }
    
    console.log('[BATCH_UPDATE_TRACKING] Updating', updates.length, 'shipments');
    
    // æ‰¹æ¬¡æ›´æ–°æ¯ç­†å‡ºè²¨ç´€éŒ„
    const results = [];
    for (const update of updates) {
      const { id, trackingNo } = update;
      
      if (!id) {
        results.push({ id, success: false, message: 'ç¼ºå°‘å‡ºè²¨ç´€éŒ„ ID' });
        continue;
      }
      
      // ğŸ”‘ å…ˆå–å¾—å‡ºè²¨ç´€éŒ„è³‡è¨Šï¼ˆç”¨æ–¼å¯„ä¿¡ï¼‰
      const getUrl = `${supabase.url}/rest/v1/shipments?id=eq.${id}&select=*,users!inner(email,real_name,nickname,cvs_store_name)`;
      const getResponse = await fetch(getUrl, {
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`
        }
      });
      
      let shipmentData = null;
      if (getResponse.ok) {
        const data = await getResponse.json();
        if (data && data.length > 0) {
          shipmentData = data[0];
          console.log('[BATCH_UPDATE_TRACKING] å‡ºè²¨ç´€éŒ„:', {
            id,
            shipment_no: shipmentData.shipment_no,
            user_email: shipmentData.users?.email || '(ç„¡)',
            user_name: shipmentData.users?.nickname || '(ç„¡)'
          });
        }
      }
      
      // æ›´æ–°ç‰©æµå–®è™Ÿ
      const url = `${supabase.url}/rest/v1/shipments?id=eq.${id}`;
      const response = await fetch(url, {
        method: 'PATCH',
        headers: {
          'apikey': supabase.apiKey,
          'Authorization': `Bearer ${supabase.apiKey}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        },
        body: JSON.stringify({
          tracking_no: trackingNo || ''
        })
      });
      
      if (response.ok) {
        results.push({ id, success: true });
        
        // ğŸ“§ å¦‚æœæœ‰å¡«å¯«ç‰©æµå–®è™Ÿä¸”å®¢æˆ¶æœ‰ emailï¼Œå¯„é€å‡ºè²¨é€šçŸ¥
        if (trackingNo && shipmentData && shipmentData.users && shipmentData.users.email) {
          try {
            const userEmail = shipmentData.users.email;
            const userName = shipmentData.users.real_name || shipmentData.users.nickname || 'å®¢æˆ¶';
            const shipmentNo = shipmentData.shipment_no || id;
            const items = shipmentData.items || 'æœªæä¾›å•†å“è³‡è¨Š';
            const storeName = shipmentData.users.cvs_store_name || '';
            
            console.log('[BATCH_UPDATE_TRACKING] æº–å‚™å¯„é€ email çµ¦:', userEmail);
            await sendShipmentNotificationEmail(userEmail, userName, shipmentNo, trackingNo, items, storeName);
            console.log(`[BATCH_UPDATE_TRACKING] âœ… Email å·²å¯„é€çµ¦ ${userEmail}`);
          } catch (emailError) {
            console.error('[BATCH_UPDATE_TRACKING] âŒ Email å¯„é€å¤±æ•—:', emailError);
            // ä¸å½±éŸ¿æ›´æ–°çµæœ
          }
        } else {
          console.log('[BATCH_UPDATE_TRACKING] â­ï¸ è·³é email ç™¼é€:', {
            has_tracking: !!trackingNo,
            has_shipment_data: !!shipmentData,
            has_users: !!(shipmentData?.users),
            has_email: !!(shipmentData?.users?.email)
          });
        }
      } else {
        const errorText = await response.text();
        results.push({ id, success: false, message: errorText });
      }
    }
    
    const successCount = results.filter(r => r.success).length;
    const failCount = results.length - successCount;
    
    return {
      success: true,
      message: `æˆåŠŸæ›´æ–° ${successCount} ç­†ï¼Œå¤±æ•— ${failCount} ç­†`,
      results
    };
  } catch (error) {
    console.error('[BATCH_UPDATE_TRACKING] Error:', error);
    return { success: false, message: 'æ‰¹æ¬¡æ›´æ–°å¤±æ•—: ' + error.message };
  }
}

/**
 * åˆªé™¤å‡ºè²¨ç´€éŒ„
 */
async function handleDeleteShipment(body, supabase) {
  try {
    const { shipmentId } = body;
    
    if (!shipmentId) {
      return { success: false, message: 'ç¼ºå°‘å‡ºè²¨ç´€éŒ„ ID' };
    }
    
    console.log('[DELETE_SHIPMENT] Deleting shipment:', shipmentId);
    
    const url = `${supabase.url}/rest/v1/shipments?id=eq.${shipmentId}`;
    const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        'apikey': supabase.apiKey,
        'Authorization': `Bearer ${supabase.apiKey}`,
        'Prefer': 'return=minimal'
      }
    });
    
    if (response.ok) {
      return { success: true, message: 'å‡ºè²¨ç´€éŒ„å·²åˆªé™¤' };
    } else {
      const errorText = await response.text();
      return { success: false, message: 'åˆªé™¤å‡ºè²¨ç´€éŒ„å¤±æ•—: ' + errorText };
    }
  } catch (error) {
    console.error('[DELETE_SHIPMENT] Error:', error);
    return { success: false, message: 'åˆªé™¤å‡ºè²¨ç´€éŒ„å¤±æ•—: ' + error.message };
  }
}

// ==================== å‰ç«¯ HTML ====================


